<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Coding Pattern: Dynamic Programming | iHelio</title>
<meta name="keywords" content="">
<meta name="description" content="Preface
Facing the Dynamic Programming Challenge
Like many others, I initially found Dynamic Programming (DP) on LeetCode daunting and perplexing. However, this challenging journey led to profound insights. My initial misconception was that DP was all about complexity, but I learned it&rsquo;s fundamentally about simplifying complex problems into manageable segments. Here&rsquo;s my journey into understanding DP and why it&rsquo;s a crucial tool in a programmer&rsquo;s toolkit.
Unraveling Dynamic Programming
The Essence of DP">
<meta name="author" content="Me">
<link rel="canonical" href="/posts/2023/coding-pattern-dynamic-programming/">
<meta name="google-site-verification" content="XYZabc">
<meta name="yandex-verification" content="XYZabc">
<meta name="msvalidate.01" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="/posts/2023/coding-pattern-dynamic-programming/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-R4SSGN5Y2Z"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-R4SSGN5Y2Z');
        }
      </script><meta property="og:url" content="/posts/2023/coding-pattern-dynamic-programming/">
  <meta property="og:site_name" content="iHelio">
  <meta property="og:title" content="Coding Pattern: Dynamic Programming">
  <meta property="og:description" content="Preface Facing the Dynamic Programming Challenge
Like many others, I initially found Dynamic Programming (DP) on LeetCode daunting and perplexing. However, this challenging journey led to profound insights. My initial misconception was that DP was all about complexity, but I learned it’s fundamentally about simplifying complex problems into manageable segments. Here’s my journey into understanding DP and why it’s a crucial tool in a programmer’s toolkit.
Unraveling Dynamic Programming The Essence of DP">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-11-30T16:28:21-04:00">
    <meta property="article:modified_time" content="2023-11-30T16:28:21-04:00">
      <meta property="og:image" content="/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name="twitter:title" content="Coding Pattern: Dynamic Programming">
<meta name="twitter:description" content="Preface
Facing the Dynamic Programming Challenge
Like many others, I initially found Dynamic Programming (DP) on LeetCode daunting and perplexing. However, this challenging journey led to profound insights. My initial misconception was that DP was all about complexity, but I learned it&rsquo;s fundamentally about simplifying complex problems into manageable segments. Here&rsquo;s my journey into understanding DP and why it&rsquo;s a crucial tool in a programmer&rsquo;s toolkit.
Unraveling Dynamic Programming
The Essence of DP">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/posts/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Coding Pattern: Dynamic Programming",
      "item": "/posts/2023/coding-pattern-dynamic-programming/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Coding Pattern: Dynamic Programming",
  "name": "Coding Pattern: Dynamic Programming",
  "description": "Preface Facing the Dynamic Programming Challenge\nLike many others, I initially found Dynamic Programming (DP) on LeetCode daunting and perplexing. However, this challenging journey led to profound insights. My initial misconception was that DP was all about complexity, but I learned it\u0026rsquo;s fundamentally about simplifying complex problems into manageable segments. Here\u0026rsquo;s my journey into understanding DP and why it\u0026rsquo;s a crucial tool in a programmer\u0026rsquo;s toolkit.\nUnraveling Dynamic Programming The Essence of DP\n",
  "keywords": [
    
  ],
  "articleBody": "Preface Facing the Dynamic Programming Challenge\nLike many others, I initially found Dynamic Programming (DP) on LeetCode daunting and perplexing. However, this challenging journey led to profound insights. My initial misconception was that DP was all about complexity, but I learned it’s fundamentally about simplifying complex problems into manageable segments. Here’s my journey into understanding DP and why it’s a crucial tool in a programmer’s toolkit.\nUnraveling Dynamic Programming The Essence of DP\nAt its heart, Dynamic Programming is a method to efficiently solve problems by breaking them into smaller, interdependent subproblems. This approach is akin to Divide-and-Conquer and Recursion, but with a unique twist: the subproblems in DP are not independent. The solution to one affects the others, creating a web of dependencies that must be navigated carefully.\nTwo Key Questions of DP:\nWhat is the optimal (maximum or minimum) outcome? How many distinct solutions exist? DP provides structured frameworks to tackle these questions effectively.\nThe DP Framework: A Three-Step Process 1. Define States and Variables:\nIdentifying ‘states’ is crucial. In DP, a state represents a specific condition or scenario within the problem. For instance, in calculating Fibonacci(10), the states include Fibonacci(9) and Fibonacci(8). 2. Transition Between States:\nThe core of DP lies in figuring out how these states evolve from one to another. Using our Fibonacci example, the transition is defined by Fibonacci(10) = Fibonacci(9) + Fibonacci(8). It’s about finding a pattern or a rule that governs this evolution. 3. Establish Base Cases:\nBase cases act as the starting point for the recursive journey of DP solutions. They are typically straightforward and known. In the Fibonacci sequence, they are Fibonacci(1) = 1 and Fibonacci(2) = 1. Approaches: Top-down and Bottom-up Top-down (Memoization):\nThis approach feels natural as it mirrors human problem-solving: start from the end goal and work backward. Memoization, an optimization technique, stores results of expensive function calls and returns the cached result when the same inputs occur again. Bottom-up (Tabulation):\nMore iterative and often faster, Bottom-up systematically solves and stores the results of all subproblems. It eliminates the need for recursion, thereby saving memory overhead. Understanding Time and Space Complexity Both approaches converge on time complexity but can differ in execution speed and memory usage. The complexity often depends on the number of states and transitions involved.\nTime Complexity: Generally, it correlates with the total states processed. For instance, in a DP solution with states $dp(i, j)$, if $i \\leq m$ and $j \\leq n$, the time complexity is typically $O(mn)$.\nSpace Complexity: Varies between the two methods. Top-down’s space complexity includes the recursion stack, while Bottom-up’s aligns closely with its time complexity due to pre-allocation of state storage.\nClassic Problems 1D Dynamic Programming 1D DP refers to the problems we could use one state variable to define the state, such as House Robber.\n# Bottom-up approach class Solution: def rob(self, nums: List[int]) -\u003e int: if len(nums) == 1: return nums[0] # There are n houses, so the number of states is n dp = [0] * len(nums) # The state variable is i, and dp[i] states the max money robbed at ith house # The base case at 0th and 1th house dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): # The recurrence relation # 1. Not robbing ith house, the max money should be equal to i-1 # 2. Robbing ith house, then (i - 1)th house cannot be robbed dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]) # return dp[n - 1] return dp[-1] Multi-Dimension Dynamic Programming Multi-Dimension DP represents the problem we need to use more than 1 state variable to represent the state such as Maximum Score from Performing Multiplication Operations\n# Top-down approach class Solution: def maximumScore(self, nums: List[int], multipliers: List[int]) -\u003e int: # Using two state variables, i and left, i is index of multipliers and left is the pointer indicating the potential number take from left end @cache def helper(i, left): # Base case, if we have used up all operations, then we have no value gain any more if i == len(multipliers): return 0 # compute the position of right pointer we could use right = len(nums) - 1 - (i - left) # the transition pattern includes two cases # we take the number either from left or right return max(helper(i + 1, left + 1) + nums[left] * multipliers[i], helper(i + 1, left) + nums[right] * multipliers[i]) # we should return helper(0, 0) since it is on the top given our state variable - when no operations are executed yet return helper(0, 0) Path and Count DP Count Problems: The Quest for Total Solutions Count problems in Dynamic Programming focus on determining the total number of possible solutions to a problem. A classic example is the Coin Change II problem on LeetCode. Here, the challenge is to find out how many distinct combinations of given coins can sum up to a target amount. It’s not just about whether a solution exists, but rather how many different ways there are to achieve it. This type of problem leverages DP’s ability to explore and count all potential combinations efficiently.\nPath Problems: Charting Routes through Constraints Path problems, while similar to Count problems, often present a slightly different challenge. These problems typically involve navigating through a grid or matrix to find all possible paths from a start point to an end point. The key to applying DP effectively here lies in the movement constraints. For instance, if movement is limited to only right and down in a grid, DP is an ideal approach. However, if movement includes all four directions (up, down, left, right), the problem complexity increases, potentially requiring alternative strategies like Breadth-First Search (BFS) or Depth-First Search (DFS). In these unrestricted movement scenarios, using DP might lead to revisiting the same cell multiple times, making it less efficient.\nLet’s use Coin Change II to learn how to solve Count DP.\nclass Solution: def change(self, amount: int, coins: List[int]) -\u003e int: # Top Down approach # We use the target amount and i as the state variables indicating the number of combinations we can make for this amount using the coins starting from i in the list @cache def helper(amount, i): # When the amount is 0, which means we have a viable combination and we should return 1 if amount == 0: return 1 # if the amount is less than 0, then we don't have a viable combination, in all other cases, we should keep looking if amount \u003c 0: return 0 out = 0 # We will try each coin starting at i for i in range(i, len(coins)): # we accumulate the possible combinations we find as the final output # since we have infinite number of coins, we could try first possible coin till we cannot - this is similiar with DFS. Once we tried all possible combinations starting at ith, we could move to (i + 1)th coin # remember one common pitfall about Count DP is to deduplicate the solution, since we return 1 once we have a viable solution, we need make sure our search path will not duplicate - which means once we tried all possible ways starting with ith coin, we should not include it in our following search out += helper(amount - coins[i], i) return out # The problem case should be helper(amount, 0) given how we define our state variables (see the beginning) return helper(amount, 0) Let’s use 63. Unique Paths II to learn Path DP.\nclass Solution: # Use Bottom-up approach def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -\u003e int: # If the start is blocked, then we cannot move if obstacleGrid[0][0] == 1: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) # Preallocate the space for dp states # dp[i][j] represents the uniquePath at (i, j) in the grid dp = [[0] * n for _ in range(m)] # base case, there is only 1 way at (0, 0) dp[0][0] = 1 # go through all possible states for i in range(m): for j in range(n): # if there is a blocker, it cannot be reached if obstacleGrid[i][j] == 1: continue # since the agent can only move down or right, the number of unique paths will be the sum of the unique paths at its top and left # it is dp[i][j] = dp[i - 1][j] + dp[i][j - 1], here we need handle the out of boundary case if i - 1 \u003e= 0: dp[i][j] += dp[i - 1][j] if j - 1 \u003e= 0: dp[i][j] += dp[i][j - 1] # the problem case will be dp[m][n] where is the bottom-right cell return dp[-1][-1] Iteration and Inaction Recurrence Relation In some cases, we need to iterate through some possibility to find the optimal solution, like the Coin Change problem we saw in [[#Path and Count DP]].\nAnother case is we might need skip the current operation.\nLike 188. Best Time to Buy and Sell Stock IV, we need decide if we should buy, sell or hold to maximize our gain in the stock.\nclass Solution: # Use top-down approach def maxProfit(self, k: int, prices: List[int]) -\u003e int: # there are three state variables # - leftTransactions: how many transactions we can still make # - i: the ith day in our trading period # - holding: whether we have the stock at our hands # it represnts the max gain we can get given the above state @cache def helper(leftTransactions, i, holding): # if we cannot make any transactions or pass the trading window, we cannot make any more profit, so the max gain is 0 if leftTransactions == 0 or i == len(prices): return 0 out = 0 # One choice is we do nothing on ith day, so we could pass our state to the next day out = max(out, helper(leftTransactions, i + 1, holding)) # if we don't hold the stock, we could choose to buy it on ith day and our gain need subtract the cost of purchase if holding == 0: out = max(out, -prices[i] + helper(leftTransactions, i + 1, 1)) # if we have the stock, we could choose to sell it and the profit will be price on ith day elif holding == 1: out = max(out, prices[i] + helper(leftTransactions - 1, i + 1, 0)) return out # thus we should return helper(k, 0, 0) indicating the max gain we can get when we can make k transactions starting day 0 without holding it return helper(k, 0, 0) Kadane’s Algorithm See My introduction to Kadane’s Algorithm\n",
  "wordCount" : "1764",
  "inLanguage": "en",
  "image": "/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished": "2023-11-30T16:28:21-04:00",
  "dateModified": "2023-11-30T16:28:21-04:00",
  "author":{
    "@type": "Person",
    "name": "Me"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/posts/2023/coding-pattern-dynamic-programming/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "iHelio",
    "logo": {
      "@type": "ImageObject",
      "url": "/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Home (Alt + H)">
                <img src="/apple-touch-icon.png" alt="" aria-label="logo"
                    height="35">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="/">Home</a>&nbsp;»&nbsp;<a href="/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Coding Pattern: Dynamic Programming
    </h1>
    <div class="post-meta"><span title='2023-11-30 16:28:21 -0400 -0400'>November 30, 2023</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1764 words&nbsp;·&nbsp;Me

</div>
  </header> 
  <div class="post-content"><h1 id="preface">Preface<a hidden class="anchor" aria-hidden="true" href="#preface">#</a></h1>
<p><strong>Facing the Dynamic Programming Challenge</strong></p>
<p>Like many others, I initially found Dynamic Programming (DP) on LeetCode daunting and perplexing. However, this challenging journey led to profound insights. My initial misconception was that DP was all about complexity, but I learned it&rsquo;s fundamentally about simplifying complex problems into manageable segments. Here&rsquo;s my journey into understanding DP and why it&rsquo;s a crucial tool in a programmer&rsquo;s toolkit.</p>
<h1 id="unraveling-dynamic-programming">Unraveling Dynamic Programming<a hidden class="anchor" aria-hidden="true" href="#unraveling-dynamic-programming">#</a></h1>
<p><strong>The Essence of DP</strong></p>
<p>At its heart, Dynamic Programming is a method to efficiently solve problems by breaking them into smaller, interdependent subproblems. This approach is akin to Divide-and-Conquer and Recursion, but with a unique twist: the subproblems in DP are not independent. The solution to one affects the others, creating a web of dependencies that must be navigated carefully.</p>
<p><strong>Two Key Questions of DP:</strong></p>
<ol>
<li>What is the optimal (maximum or minimum) outcome?</li>
<li>How many distinct solutions exist?</li>
</ol>
<p>DP provides structured frameworks to tackle these questions effectively.</p>
<h1 id="the-dp-framework-a-three-step-process">The DP Framework: A Three-Step Process<a hidden class="anchor" aria-hidden="true" href="#the-dp-framework-a-three-step-process">#</a></h1>
<p><strong>1. Define States and Variables:</strong></p>
<ul>
<li>Identifying &lsquo;states&rsquo; is crucial. In DP, a state represents a specific condition or scenario within the problem. For instance, in calculating Fibonacci(10), the states include Fibonacci(9) and Fibonacci(8).</li>
</ul>
<p><strong>2. Transition Between States:</strong></p>
<ul>
<li>The core of DP lies in figuring out how these states evolve from one to another. Using our Fibonacci example, the transition is defined by Fibonacci(10) = Fibonacci(9) + Fibonacci(8). It&rsquo;s about finding a pattern or a rule that governs this evolution.</li>
</ul>
<p><strong>3. Establish Base Cases:</strong></p>
<ul>
<li>Base cases act as the starting point for the recursive journey of DP solutions. They are typically straightforward and known. In the Fibonacci sequence, they are Fibonacci(1) = 1 and Fibonacci(2) = 1.</li>
</ul>
<h2 id="approaches-top-down-and-bottom-up">Approaches: Top-down and Bottom-up<a hidden class="anchor" aria-hidden="true" href="#approaches-top-down-and-bottom-up">#</a></h2>
<p><strong>Top-down (Memoization):</strong></p>
<ul>
<li>This approach feels natural as it mirrors human problem-solving: start from the end goal and work backward. Memoization, an optimization technique, stores results of expensive function calls and returns the cached result when the same inputs occur again.</li>
</ul>
<p><strong>Bottom-up (Tabulation):</strong></p>
<ul>
<li>More iterative and often faster, Bottom-up systematically solves and stores the results of all subproblems. It eliminates the need for recursion, thereby saving memory overhead.</li>
</ul>
<h3 id="understanding-time-and-space-complexity">Understanding Time and Space Complexity<a hidden class="anchor" aria-hidden="true" href="#understanding-time-and-space-complexity">#</a></h3>
<p>Both approaches converge on time complexity but can differ in execution speed and memory usage. The complexity often depends on the number of states and transitions involved.</p>
<p><strong>Time Complexity:</strong> Generally, it correlates with the total states processed. For instance, in a DP solution with states $dp(i, j)$, if $i \leq m$ and $j \leq n$, the time complexity is typically $O(mn)$.</p>
<p><strong>Space Complexity:</strong> Varies between the two methods. Top-down&rsquo;s space complexity includes the recursion stack, while Bottom-up&rsquo;s aligns closely with its time complexity due to pre-allocation of state storage.</p>
<h1 id="classic-problems">Classic Problems<a hidden class="anchor" aria-hidden="true" href="#classic-problems">#</a></h1>
<h2 id="1d-dynamic-programming">1D Dynamic Programming<a hidden class="anchor" aria-hidden="true" href="#1d-dynamic-programming">#</a></h2>
<p>1D DP refers to the problems we could use one state variable to define the state, such as <a href="https://leetcode.com/problems/house-robber/">House Robber</a>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Bottom-up approach</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">rob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># There are n houses, so the number of states is n</span>
</span></span><span class="line"><span class="cl">        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># The state variable is i, and dp[i] states the max money robbed at ith house</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># The base case at 0th and 1th house</span>
</span></span><span class="line"><span class="cl">        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">	        <span class="c1"># The recurrence relation </span>
</span></span><span class="line"><span class="cl">	        <span class="c1"># 1. Not robbing ith house, the max money should be equal to i-1</span>
</span></span><span class="line"><span class="cl">	        <span class="c1"># 2. Robbing ith house, then (i - 1)th house cannot be robbed</span>
</span></span><span class="line"><span class="cl">            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># return dp[n - 1]</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span></code></pre></div><h2 id="multi-dimension-dynamic-programming">Multi-Dimension Dynamic Programming<a hidden class="anchor" aria-hidden="true" href="#multi-dimension-dynamic-programming">#</a></h2>
<p>Multi-Dimension DP represents the problem we need to use more than 1 state variable to represent the state such as <a href="https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations/">Maximum Score from Performing Multiplication Operations</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># Top-down approach</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">maximumScore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">multipliers</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1"># Using two state variables, i and left, i is index of multipliers and left is the pointer indicating the potential number take from left end</span>
</span></span><span class="line"><span class="cl">        <span class="nd">@cache</span>
</span></span><span class="line"><span class="cl">        <span class="k">def</span> <span class="nf">helper</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	        <span class="c1"># Base case, if we have used up all operations, then we have no value gain any more</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">multipliers</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># compute the position of right pointer we could use</span>
</span></span><span class="line"><span class="cl">            <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># the transition pattern includes two cases</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># we take the number either from left or right</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">helper</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">*</span> <span class="n">multipliers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">helper</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">*</span> <span class="n">multipliers</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># we should return helper(0, 0) since it is on the top given our state variable - when no operations are executed yet</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">helper</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="path-and-count-dp">Path and Count DP<a hidden class="anchor" aria-hidden="true" href="#path-and-count-dp">#</a></h2>
<p><strong>Count Problems: The Quest for Total Solutions</strong> Count problems in Dynamic Programming focus on determining the total number of possible solutions to a problem. A classic example is the <a href="https://leetcode.com/problems/coin-change-ii/">Coin Change II problem on LeetCode</a>. Here, the challenge is to find out how many distinct combinations of given coins can sum up to a target amount. It&rsquo;s not just about whether a solution exists, but rather how many different ways there are to achieve it. This type of problem leverages DP&rsquo;s ability to explore and count all potential combinations efficiently.</p>
<p><strong>Path Problems: Charting Routes through Constraints</strong> Path problems, while similar to Count problems, often present a slightly different challenge. These problems typically involve navigating through a grid or matrix to find all possible paths from a start point to an end point. The key to applying DP effectively here lies in the movement constraints. For instance, if movement is limited to only right and down in a grid, DP is an ideal approach. However, if movement includes all four directions (up, down, left, right), the problem complexity increases, potentially requiring alternative strategies like Breadth-First Search (BFS) or Depth-First Search (DFS). In these unrestricted movement scenarios, using DP might lead to revisiting the same cell multiple times, making it less efficient.</p>
<p><img loading="lazy" src="https://i.imgur.com/BWiozAJ.png"></p>
<p>Let&rsquo;s use <a href="https://leetcode.com/problems/coin-change-ii/">Coin Change II</a> to learn how to solve Count DP.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">coins</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Top Down approach</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># We use the target amount and i as the state variables indicating the number of combinations we can make for this amount using the coins starting from i in the list</span>
</span></span><span class="line"><span class="cl">        <span class="nd">@cache</span>
</span></span><span class="line"><span class="cl">        <span class="k">def</span> <span class="nf">helper</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	        <span class="c1"># When the amount is 0, which means we have a viable combination and we should return 1</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># if the amount is less than 0, then we don&#39;t have a viable combination, in all other cases, we should keep looking</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">amount</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># We will try each coin starting at i</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coins</span><span class="p">)):</span>
</span></span><span class="line"><span class="cl">	            <span class="c1"># we accumulate the possible combinations we find as the final output</span>
</span></span><span class="line"><span class="cl">	            <span class="c1"># since we have infinite number of coins, we could try first possible coin till we cannot - this is similiar with DFS. Once we tried all possible combinations starting at ith, we could move to (i + 1)th coin</span>
</span></span><span class="line"><span class="cl">	            <span class="c1"># remember one common pitfall about Count DP is to deduplicate the solution, since we return 1 once we have a viable solution, we need make sure our search path will not duplicate - which means once we tried all possible ways starting with ith coin, we should not include it in our following search</span>
</span></span><span class="line"><span class="cl">                <span class="n">out</span> <span class="o">+=</span> <span class="n">helper</span><span class="p">(</span><span class="n">amount</span> <span class="o">-</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">out</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># The problem case should be helper(amount, 0) given how we define our state variables (see the beginning)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">helper</span><span class="p">(</span><span class="n">amount</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></div><p>Let&rsquo;s use <a href="https://leetcode.com/problems/unique-paths-ii/">63. Unique Paths II</a> to learn Path DP.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="c1"># Use Bottom-up approach</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">uniquePathsWithObstacles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstacleGrid</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># If the start is blocked, then we cannot move </span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obstacleGrid</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">obstacleGrid</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># Preallocate the space for dp states</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># dp[i][j] represents the uniquePath at (i, j) in the grid</span>
</span></span><span class="line"><span class="cl">        <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1"># base case, there is only 1 way at (0, 0)</span>
</span></span><span class="line"><span class="cl">        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1"># go through all possible states</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	            <span class="c1"># if there is a blocker, it cannot be reached</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">obstacleGrid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="k">continue</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># since the agent can only move down or right, the number of unique paths will be the sum of the unique paths at its top and left</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># it is dp[i][j] = dp[i - 1][j] + dp[i][j - 1], here we need handle the out of boundary case</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># the problem case will be dp[m][n] where is the bottom-right cell</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span></code></pre></div><h2 id="iteration-and-inaction-recurrence-relation">Iteration and Inaction Recurrence Relation<a hidden class="anchor" aria-hidden="true" href="#iteration-and-inaction-recurrence-relation">#</a></h2>
<p>In some cases, we need to iterate through some possibility to find the optimal solution, like the Coin Change problem we saw in [[#Path and Count DP]].</p>
<p>Another case is we might need skip the current operation.</p>
<p>Like <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">188. Best Time to Buy and Sell Stock IV</a>, we need decide if we should buy, sell or hold to maximize our gain in the stock.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="c1"># Use top-down approach</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">maxProfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">prices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1"># there are three state variables</span>
</span></span><span class="line"><span class="cl">		<span class="c1">#  - leftTransactions: how many transactions we can still make</span>
</span></span><span class="line"><span class="cl">		<span class="c1">#  - i: the ith day in our trading period</span>
</span></span><span class="line"><span class="cl">		<span class="c1">#  - holding: whether we have the stock at our hands</span>
</span></span><span class="line"><span class="cl">		<span class="c1"># it represnts the max gain we can get given the above state</span>
</span></span><span class="line"><span class="cl">        <span class="nd">@cache</span>
</span></span><span class="line"><span class="cl">        <span class="k">def</span> <span class="nf">helper</span><span class="p">(</span><span class="n">leftTransactions</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">holding</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	        <span class="c1"># if we cannot make any transactions or pass the trading window, we cannot make any more profit, so the max gain is 0</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">leftTransactions</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">prices</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">            <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># One choice is we do nothing on ith day, so we could pass our state to the next day</span>
</span></span><span class="line"><span class="cl">            <span class="n">out</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">helper</span><span class="p">(</span><span class="n">leftTransactions</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">holding</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># if we don&#39;t hold the stock, we could choose to buy it on ith day and our gain need subtract the cost of purchase</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">holding</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">out</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">-</span><span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">helper</span><span class="p">(</span><span class="n">leftTransactions</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># if we have the stock, we could choose to sell it and the profit will be price on ith day</span>
</span></span><span class="line"><span class="cl">            <span class="k">elif</span> <span class="n">holding</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">out</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">helper</span><span class="p">(</span><span class="n">leftTransactions</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">out</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># thus we should return helper(k, 0, 0) indicating the max gain we can get when we can make k transactions starting day 0 without holding it</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">helper</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></div><h2 id="kadanes-algorithm">Kadane&rsquo;s Algorithm<a hidden class="anchor" aria-hidden="true" href="#kadanes-algorithm">#</a></h2>
<p>See <a href="https://ihelio.today/posts/2023/coding-pattern-kadanes-algo/">My introduction to Kadane&rsquo;s Algorithm</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="/posts/2023/coding-pattern-kadanes-algo/">
    <span class="title">« Prev</span>
    <br>
    <span>Coding Pattern: Kadane&#39;s Algo</span>
  </a>
  <a class="next" href="/posts/2023/coding-pattern-recursion/">
    <span class="title">Next »</span>
    <br>
    <span>Coding Pattern: Recursion</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Dynamic Programming on x"
            href="https://x.com/intent/tweet/?text=Coding%20Pattern%3a%20Dynamic%20Programming&amp;url=%2fposts%2f2023%2fcoding-pattern-dynamic-programming%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Dynamic Programming on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=%2fposts%2f2023%2fcoding-pattern-dynamic-programming%2f&amp;title=Coding%20Pattern%3a%20Dynamic%20Programming&amp;summary=Coding%20Pattern%3a%20Dynamic%20Programming&amp;source=%2fposts%2f2023%2fcoding-pattern-dynamic-programming%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Dynamic Programming on reddit"
            href="https://reddit.com/submit?url=%2fposts%2f2023%2fcoding-pattern-dynamic-programming%2f&title=Coding%20Pattern%3a%20Dynamic%20Programming">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Dynamic Programming on facebook"
            href="https://facebook.com/sharer/sharer.php?u=%2fposts%2f2023%2fcoding-pattern-dynamic-programming%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Dynamic Programming on whatsapp"
            href="https://api.whatsapp.com/send?text=Coding%20Pattern%3a%20Dynamic%20Programming%20-%20%2fposts%2f2023%2fcoding-pattern-dynamic-programming%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Dynamic Programming on telegram"
            href="https://telegram.me/share/url?text=Coding%20Pattern%3a%20Dynamic%20Programming&amp;url=%2fposts%2f2023%2fcoding-pattern-dynamic-programming%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Dynamic Programming on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Coding%20Pattern%3a%20Dynamic%20Programming&u=%2fposts%2f2023%2fcoding-pattern-dynamic-programming%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="/">iHelio</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
