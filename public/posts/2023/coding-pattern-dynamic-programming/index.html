<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Coding Pattern: Dynamic Programming | iHelio</title>
<meta name=keywords content="Algorithm,LeetCode"><meta name=description content="Preface Facing the Dynamic Programming Challenge
Like many others, I initially found Dynamic Programming (DP) on LeetCode daunting and perplexing. However, this challenging journey led to profound insights. My initial misconception was that DP was all about complexity, but I learned it&rsquo;s fundamentally about simplifying complex problems into manageable segments. Here&rsquo;s my journey into understanding DP and why it&rsquo;s a crucial tool in a programmer&rsquo;s toolkit.
Unraveling Dynamic Programming The Essence of DP"><meta name=author content="Me"><link rel=canonical href=ihelio.today/posts/2023/coding-pattern-dynamic-programming/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=ihelio.today/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=ihelio.today/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=ihelio.today/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=ihelio.today/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=ihelio.today/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=ihelio.today/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=ihelio.today/posts/2023/coding-pattern-dynamic-programming/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-R4SSGN5Y2Z"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-R4SSGN5Y2Z")}</script><meta property="og:url" content="ihelio.today/posts/2023/coding-pattern-dynamic-programming/"><meta property="og:site_name" content="iHelio"><meta property="og:title" content="Coding Pattern: Dynamic Programming"><meta property="og:description" content="Preface Facing the Dynamic Programming Challenge
Like many others, I initially found Dynamic Programming (DP) on LeetCode daunting and perplexing. However, this challenging journey led to profound insights. My initial misconception was that DP was all about complexity, but I learned it’s fundamentally about simplifying complex problems into manageable segments. Here’s my journey into understanding DP and why it’s a crucial tool in a programmer’s toolkit.
Unraveling Dynamic Programming The Essence of DP"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-30T16:28:21-04:00"><meta property="article:modified_time" content="2023-11-30T16:28:21-04:00"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="LeetCode"><meta property="og:image" content="ihelio.today/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="ihelio.today/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Coding Pattern: Dynamic Programming"><meta name=twitter:description content="Preface Facing the Dynamic Programming Challenge
Like many others, I initially found Dynamic Programming (DP) on LeetCode daunting and perplexing. However, this challenging journey led to profound insights. My initial misconception was that DP was all about complexity, but I learned it&rsquo;s fundamentally about simplifying complex problems into manageable segments. Here&rsquo;s my journey into understanding DP and why it&rsquo;s a crucial tool in a programmer&rsquo;s toolkit.
Unraveling Dynamic Programming The Essence of DP"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"ihelio.today/posts/"},{"@type":"ListItem","position":2,"name":"Coding Pattern: Dynamic Programming","item":"ihelio.today/posts/2023/coding-pattern-dynamic-programming/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Coding Pattern: Dynamic Programming","name":"Coding Pattern: Dynamic Programming","description":"Preface Facing the Dynamic Programming Challenge\nLike many others, I initially found Dynamic Programming (DP) on LeetCode daunting and perplexing. However, this challenging journey led to profound insights. My initial misconception was that DP was all about complexity, but I learned it\u0026rsquo;s fundamentally about simplifying complex problems into manageable segments. Here\u0026rsquo;s my journey into understanding DP and why it\u0026rsquo;s a crucial tool in a programmer\u0026rsquo;s toolkit.\nUnraveling Dynamic Programming The Essence of DP","keywords":["Algorithm","LeetCode"],"articleBody":"Preface Facing the Dynamic Programming Challenge\nLike many others, I initially found Dynamic Programming (DP) on LeetCode daunting and perplexing. However, this challenging journey led to profound insights. My initial misconception was that DP was all about complexity, but I learned it’s fundamentally about simplifying complex problems into manageable segments. Here’s my journey into understanding DP and why it’s a crucial tool in a programmer’s toolkit.\nUnraveling Dynamic Programming The Essence of DP\nAt its heart, Dynamic Programming is a method to efficiently solve problems by breaking them into smaller, interdependent subproblems. This approach is akin to Divide-and-Conquer and Recursion, but with a unique twist: the subproblems in DP are not independent. The solution to one affects the others, creating a web of dependencies that must be navigated carefully.\nTwo Key Questions of DP:\nWhat is the optimal (maximum or minimum) outcome? How many distinct solutions exist? DP provides structured frameworks to tackle these questions effectively.\nThe DP Framework: A Three-Step Process 1. Define States and Variables:\nIdentifying ‘states’ is crucial. In DP, a state represents a specific condition or scenario within the problem. For instance, in calculating Fibonacci(10), the states include Fibonacci(9) and Fibonacci(8). 2. Transition Between States:\nThe core of DP lies in figuring out how these states evolve from one to another. Using our Fibonacci example, the transition is defined by Fibonacci(10) = Fibonacci(9) + Fibonacci(8). It’s about finding a pattern or a rule that governs this evolution. 3. Establish Base Cases:\nBase cases act as the starting point for the recursive journey of DP solutions. They are typically straightforward and known. In the Fibonacci sequence, they are Fibonacci(1) = 1 and Fibonacci(2) = 1. Approaches: Top-down and Bottom-up Top-down (Memoization):\nThis approach feels natural as it mirrors human problem-solving: start from the end goal and work backward. Memoization, an optimization technique, stores results of expensive function calls and returns the cached result when the same inputs occur again. Bottom-up (Tabulation):\nMore iterative and often faster, Bottom-up systematically solves and stores the results of all subproblems. It eliminates the need for recursion, thereby saving memory overhead. Understanding Time and Space Complexity Both approaches converge on time complexity but can differ in execution speed and memory usage. The complexity often depends on the number of states and transitions involved.\nTime Complexity: Generally, it correlates with the total states processed. For instance, in a DP solution with states $dp(i, j)$, if $i \\leq m$ and $j \\leq n$, the time complexity is typically $O(mn)$.\nSpace Complexity: Varies between the two methods. Top-down’s space complexity includes the recursion stack, while Bottom-up’s aligns closely with its time complexity due to pre-allocation of state storage.\nClassic Problems 1D Dynamic Programming 1D DP refers to the problems we could use one state variable to define the state, such as House Robber.\n# Bottom-up approach class Solution: def rob(self, nums: List[int]) -\u003e int: if len(nums) == 1: return nums[0] # There are n houses, so the number of states is n dp = [0] * len(nums) # The state variable is i, and dp[i] states the max money robbed at ith house # The base case at 0th and 1th house dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): # The recurrence relation # 1. Not robbing ith house, the max money should be equal to i-1 # 2. Robbing ith house, then (i - 1)th house cannot be robbed dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]) # return dp[n - 1] return dp[-1] Multi-Dimension Dynamic Programming Multi-Dimension DP represents the problem we need to use more than 1 state variable to represent the state such as Maximum Score from Performing Multiplication Operations\n# Top-down approach class Solution: def maximumScore(self, nums: List[int], multipliers: List[int]) -\u003e int: # Using two state variables, i and left, i is index of multipliers and left is the pointer indicating the potential number take from left end @cache def helper(i, left): # Base case, if we have used up all operations, then we have no value gain any more if i == len(multipliers): return 0 # compute the position of right pointer we could use right = len(nums) - 1 - (i - left) # the transition pattern includes two cases # we take the number either from left or right return max(helper(i + 1, left + 1) + nums[left] * multipliers[i], helper(i + 1, left) + nums[right] * multipliers[i]) # we should return helper(0, 0) since it is on the top given our state variable - when no operations are executed yet return helper(0, 0) Path and Count DP Count Problems: The Quest for Total Solutions Count problems in Dynamic Programming focus on determining the total number of possible solutions to a problem. A classic example is the Coin Change II problem on LeetCode. Here, the challenge is to find out how many distinct combinations of given coins can sum up to a target amount. It’s not just about whether a solution exists, but rather how many different ways there are to achieve it. This type of problem leverages DP’s ability to explore and count all potential combinations efficiently.\nPath Problems: Charting Routes through Constraints Path problems, while similar to Count problems, often present a slightly different challenge. These problems typically involve navigating through a grid or matrix to find all possible paths from a start point to an end point. The key to applying DP effectively here lies in the movement constraints. For instance, if movement is limited to only right and down in a grid, DP is an ideal approach. However, if movement includes all four directions (up, down, left, right), the problem complexity increases, potentially requiring alternative strategies like Breadth-First Search (BFS) or Depth-First Search (DFS). In these unrestricted movement scenarios, using DP might lead to revisiting the same cell multiple times, making it less efficient.\nLet’s use Coin Change II to learn how to solve Count DP.\nclass Solution: def change(self, amount: int, coins: List[int]) -\u003e int: # Top Down approach # We use the target amount and i as the state variables indicating the number of combinations we can make for this amount using the coins starting from i in the list @cache def helper(amount, i): # When the amount is 0, which means we have a viable combination and we should return 1 if amount == 0: return 1 # if the amount is less than 0, then we don't have a viable combination, in all other cases, we should keep looking if amount \u003c 0: return 0 out = 0 # We will try each coin starting at i for i in range(i, len(coins)): # we accumulate the possible combinations we find as the final output # since we have infinite number of coins, we could try first possible coin till we cannot - this is similiar with DFS. Once we tried all possible combinations starting at ith, we could move to (i + 1)th coin # remember one common pitfall about Count DP is to deduplicate the solution, since we return 1 once we have a viable solution, we need make sure our search path will not duplicate - which means once we tried all possible ways starting with ith coin, we should not include it in our following search out += helper(amount - coins[i], i) return out # The problem case should be helper(amount, 0) given how we define our state variables (see the beginning) return helper(amount, 0) Let’s use 63. Unique Paths II to learn Path DP.\nclass Solution: # Use Bottom-up approach def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -\u003e int: # If the start is blocked, then we cannot move if obstacleGrid[0][0] == 1: return 0 m, n = len(obstacleGrid), len(obstacleGrid[0]) # Preallocate the space for dp states # dp[i][j] represents the uniquePath at (i, j) in the grid dp = [[0] * n for _ in range(m)] # base case, there is only 1 way at (0, 0) dp[0][0] = 1 # go through all possible states for i in range(m): for j in range(n): # if there is a blocker, it cannot be reached if obstacleGrid[i][j] == 1: continue # since the agent can only move down or right, the number of unique paths will be the sum of the unique paths at its top and left # it is dp[i][j] = dp[i - 1][j] + dp[i][j - 1], here we need handle the out of boundary case if i - 1 \u003e= 0: dp[i][j] += dp[i - 1][j] if j - 1 \u003e= 0: dp[i][j] += dp[i][j - 1] # the problem case will be dp[m][n] where is the bottom-right cell return dp[-1][-1] Iteration and Inaction Recurrence Relation In some cases, we need to iterate through some possibility to find the optimal solution, like the Coin Change problem we saw in [[#Path and Count DP]].\nAnother case is we might need skip the current operation.\nLike 188. Best Time to Buy and Sell Stock IV, we need decide if we should buy, sell or hold to maximize our gain in the stock.\nclass Solution: # Use top-down approach def maxProfit(self, k: int, prices: List[int]) -\u003e int: # there are three state variables # - leftTransactions: how many transactions we can still make # - i: the ith day in our trading period # - holding: whether we have the stock at our hands # it represnts the max gain we can get given the above state @cache def helper(leftTransactions, i, holding): # if we cannot make any transactions or pass the trading window, we cannot make any more profit, so the max gain is 0 if leftTransactions == 0 or i == len(prices): return 0 out = 0 # One choice is we do nothing on ith day, so we could pass our state to the next day out = max(out, helper(leftTransactions, i + 1, holding)) # if we don't hold the stock, we could choose to buy it on ith day and our gain need subtract the cost of purchase if holding == 0: out = max(out, -prices[i] + helper(leftTransactions, i + 1, 1)) # if we have the stock, we could choose to sell it and the profit will be price on ith day elif holding == 1: out = max(out, prices[i] + helper(leftTransactions - 1, i + 1, 0)) return out # thus we should return helper(k, 0, 0) indicating the max gain we can get when we can make k transactions starting day 0 without holding it return helper(k, 0, 0) Kadane’s Algorithm See My introduction to Kadane’s Algorithm\n","wordCount":"1764","inLanguage":"en","image":"ihelio.today/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-11-30T16:28:21-04:00","dateModified":"2023-11-30T16:28:21-04:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"ihelio.today/posts/2023/coding-pattern-dynamic-programming/"},"publisher":{"@type":"Organization","name":"iHelio","logo":{"@type":"ImageObject","url":"ihelio.today/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=ihelio.today/ accesskey=h title="Home (Alt + H)"><img src=/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=ihelio.today/ihelio.today/archives/ title=Archive><span>Archive</span></a></li><li><a href=ihelio.today/ihelio.today/categories/ title=Categories><span>Categories</span></a></li><li><a href=ihelio.today/search/ title=Search><span>Search</span></a></li><li><a href=ihelio.today/ihelio.today/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=ihelio.today/>Home</a>&nbsp;»&nbsp;<a href=ihelio.today/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Coding Pattern: Dynamic Programming</h1><div class=post-meta><span title='2023-11-30 16:28:21 -0400 -0400'>November 30, 2023</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1764 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/ydeng11/ihelio/tree/main/content/posts/2023/Coding%20Pattern:%20Dynamic%20Programming.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=preface>Preface<a hidden class=anchor aria-hidden=true href=#preface>#</a></h1><p><strong>Facing the Dynamic Programming Challenge</strong></p><p>Like many others, I initially found Dynamic Programming (DP) on LeetCode daunting and perplexing. However, this challenging journey led to profound insights. My initial misconception was that DP was all about complexity, but I learned it&rsquo;s fundamentally about simplifying complex problems into manageable segments. Here&rsquo;s my journey into understanding DP and why it&rsquo;s a crucial tool in a programmer&rsquo;s toolkit.</p><h1 id=unraveling-dynamic-programming>Unraveling Dynamic Programming<a hidden class=anchor aria-hidden=true href=#unraveling-dynamic-programming>#</a></h1><p><strong>The Essence of DP</strong></p><p>At its heart, Dynamic Programming is a method to efficiently solve problems by breaking them into smaller, interdependent subproblems. This approach is akin to Divide-and-Conquer and Recursion, but with a unique twist: the subproblems in DP are not independent. The solution to one affects the others, creating a web of dependencies that must be navigated carefully.</p><p><strong>Two Key Questions of DP:</strong></p><ol><li>What is the optimal (maximum or minimum) outcome?</li><li>How many distinct solutions exist?</li></ol><p>DP provides structured frameworks to tackle these questions effectively.</p><h1 id=the-dp-framework-a-three-step-process>The DP Framework: A Three-Step Process<a hidden class=anchor aria-hidden=true href=#the-dp-framework-a-three-step-process>#</a></h1><p><strong>1. Define States and Variables:</strong></p><ul><li>Identifying &lsquo;states&rsquo; is crucial. In DP, a state represents a specific condition or scenario within the problem. For instance, in calculating Fibonacci(10), the states include Fibonacci(9) and Fibonacci(8).</li></ul><p><strong>2. Transition Between States:</strong></p><ul><li>The core of DP lies in figuring out how these states evolve from one to another. Using our Fibonacci example, the transition is defined by Fibonacci(10) = Fibonacci(9) + Fibonacci(8). It&rsquo;s about finding a pattern or a rule that governs this evolution.</li></ul><p><strong>3. Establish Base Cases:</strong></p><ul><li>Base cases act as the starting point for the recursive journey of DP solutions. They are typically straightforward and known. In the Fibonacci sequence, they are Fibonacci(1) = 1 and Fibonacci(2) = 1.</li></ul><h2 id=approaches-top-down-and-bottom-up>Approaches: Top-down and Bottom-up<a hidden class=anchor aria-hidden=true href=#approaches-top-down-and-bottom-up>#</a></h2><p><strong>Top-down (Memoization):</strong></p><ul><li>This approach feels natural as it mirrors human problem-solving: start from the end goal and work backward. Memoization, an optimization technique, stores results of expensive function calls and returns the cached result when the same inputs occur again.</li></ul><p><strong>Bottom-up (Tabulation):</strong></p><ul><li>More iterative and often faster, Bottom-up systematically solves and stores the results of all subproblems. It eliminates the need for recursion, thereby saving memory overhead.</li></ul><h3 id=understanding-time-and-space-complexity>Understanding Time and Space Complexity<a hidden class=anchor aria-hidden=true href=#understanding-time-and-space-complexity>#</a></h3><p>Both approaches converge on time complexity but can differ in execution speed and memory usage. The complexity often depends on the number of states and transitions involved.</p><p><strong>Time Complexity:</strong> Generally, it correlates with the total states processed. For instance, in a DP solution with states $dp(i, j)$, if $i \leq m$ and $j \leq n$, the time complexity is typically $O(mn)$.</p><p><strong>Space Complexity:</strong> Varies between the two methods. Top-down&rsquo;s space complexity includes the recursion stack, while Bottom-up&rsquo;s aligns closely with its time complexity due to pre-allocation of state storage.</p><h1 id=classic-problems>Classic Problems<a hidden class=anchor aria-hidden=true href=#classic-problems>#</a></h1><h2 id=1d-dynamic-programming>1D Dynamic Programming<a hidden class=anchor aria-hidden=true href=#1d-dynamic-programming>#</a></h2><p>1D DP refers to the problems we could use one state variable to define the state, such as <a href=https://leetcode.com/problems/house-robber/>House Robber</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Bottom-up approach</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>rob</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>nums</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span> <span class=k>return</span> <span class=n>nums</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=c1># There are n houses, so the number of states is n</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># The state variable is i, and dp[i] states the max money robbed at ith house</span>
</span></span><span class=line><span class=cl>        <span class=c1># The base case at 0th and 1th house</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>nums</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>nums</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>nums</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>	        <span class=c1># The recurrence relation </span>
</span></span><span class=line><span class=cl>	        <span class=c1># 1. Not robbing ith house, the max money should be equal to i-1</span>
</span></span><span class=line><span class=cl>	        <span class=c1># 2. Robbing ith house, then (i - 1)th house cannot be robbed</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=c1># return dp[n - 1]</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span></code></pre></div><h2 id=multi-dimension-dynamic-programming>Multi-Dimension Dynamic Programming<a hidden class=anchor aria-hidden=true href=#multi-dimension-dynamic-programming>#</a></h2><p>Multi-Dimension DP represents the problem we need to use more than 1 state variable to represent the state such as <a href=https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations/>Maximum Score from Performing Multiplication Operations</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Top-down approach</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>maximumScore</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>nums</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>],</span> <span class=n>multipliers</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1># Using two state variables, i and left, i is index of multipliers and left is the pointer indicating the potential number take from left end</span>
</span></span><span class=line><span class=cl>        <span class=nd>@cache</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=nf>helper</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>left</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	        <span class=c1># Base case, if we have used up all operations, then we have no value gain any more</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>i</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>multipliers</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=c1># compute the position of right pointer we could use</span>
</span></span><span class=line><span class=cl>            <span class=n>right</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>-</span> <span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1># the transition pattern includes two cases</span>
</span></span><span class=line><span class=cl>            <span class=c1># we take the number either from left or right</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>helper</span><span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>left</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>left</span><span class=p>]</span> <span class=o>*</span> <span class=n>multipliers</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>helper</span><span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>left</span><span class=p>)</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>right</span><span class=p>]</span> <span class=o>*</span> <span class=n>multipliers</span><span class=p>[</span><span class=n>i</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=c1># we should return helper(0, 0) since it is on the top given our state variable - when no operations are executed yet</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>helper</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=path-and-count-dp>Path and Count DP<a hidden class=anchor aria-hidden=true href=#path-and-count-dp>#</a></h2><p><strong>Count Problems: The Quest for Total Solutions</strong> Count problems in Dynamic Programming focus on determining the total number of possible solutions to a problem. A classic example is the <a href=https://leetcode.com/problems/coin-change-ii/>Coin Change II problem on LeetCode</a>. Here, the challenge is to find out how many distinct combinations of given coins can sum up to a target amount. It&rsquo;s not just about whether a solution exists, but rather how many different ways there are to achieve it. This type of problem leverages DP&rsquo;s ability to explore and count all potential combinations efficiently.</p><p><strong>Path Problems: Charting Routes through Constraints</strong> Path problems, while similar to Count problems, often present a slightly different challenge. These problems typically involve navigating through a grid or matrix to find all possible paths from a start point to an end point. The key to applying DP effectively here lies in the movement constraints. For instance, if movement is limited to only right and down in a grid, DP is an ideal approach. However, if movement includes all four directions (up, down, left, right), the problem complexity increases, potentially requiring alternative strategies like Breadth-First Search (BFS) or Depth-First Search (DFS). In these unrestricted movement scenarios, using DP might lead to revisiting the same cell multiple times, making it less efficient.</p><p><img loading=lazy src=https://i.imgur.com/BWiozAJ.png></p><p>Let&rsquo;s use <a href=https://leetcode.com/problems/coin-change-ii/>Coin Change II</a> to learn how to solve Count DP.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>change</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>amount</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>coins</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># Top Down approach</span>
</span></span><span class=line><span class=cl>        <span class=c1># We use the target amount and i as the state variables indicating the number of combinations we can make for this amount using the coins starting from i in the list</span>
</span></span><span class=line><span class=cl>        <span class=nd>@cache</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=nf>helper</span><span class=p>(</span><span class=n>amount</span><span class=p>,</span> <span class=n>i</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	        <span class=c1># When the amount is 0, which means we have a viable combination and we should return 1</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>amount</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=c1># if the amount is less than 0, then we don&#39;t have a viable combination, in all other cases, we should keep looking</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>amount</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>out</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=c1># We will try each coin starting at i</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>coins</span><span class=p>)):</span>
</span></span><span class=line><span class=cl>	            <span class=c1># we accumulate the possible combinations we find as the final output</span>
</span></span><span class=line><span class=cl>	            <span class=c1># since we have infinite number of coins, we could try first possible coin till we cannot - this is similiar with DFS. Once we tried all possible combinations starting at ith, we could move to (i + 1)th coin</span>
</span></span><span class=line><span class=cl>	            <span class=c1># remember one common pitfall about Count DP is to deduplicate the solution, since we return 1 once we have a viable solution, we need make sure our search path will not duplicate - which means once we tried all possible ways starting with ith coin, we should not include it in our following search</span>
</span></span><span class=line><span class=cl>                <span class=n>out</span> <span class=o>+=</span> <span class=n>helper</span><span class=p>(</span><span class=n>amount</span> <span class=o>-</span> <span class=n>coins</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>out</span>
</span></span><span class=line><span class=cl>        <span class=c1># The problem case should be helper(amount, 0) given how we define our state variables (see the beginning)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>helper</span><span class=p>(</span><span class=n>amount</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span></code></pre></div><p>Let&rsquo;s use <a href=https://leetcode.com/problems/unique-paths-ii/>63. Unique Paths II</a> to learn Path DP.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=c1># Use Bottom-up approach</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>uniquePathsWithObstacles</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>obstacleGrid</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>]])</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># If the start is blocked, then we cannot move </span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>obstacleGrid</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span> <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>m</span><span class=p>,</span> <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>obstacleGrid</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>obstacleGrid</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=c1># Preallocate the space for dp states</span>
</span></span><span class=line><span class=cl>        <span class=c1># dp[i][j] represents the uniquePath at (i, j) in the grid</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=n>n</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>m</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1># base case, there is only 1 way at (0, 0)</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1># go through all possible states</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>m</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	            <span class=c1># if there is a blocker, it cannot be reached</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>obstacleGrid</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=k>continue</span>
</span></span><span class=line><span class=cl>                <span class=c1># since the agent can only move down or right, the number of unique paths will be the sum of the unique paths at its top and left</span>
</span></span><span class=line><span class=cl>                <span class=c1># it is dp[i][j] = dp[i - 1][j] + dp[i][j - 1], here we need handle the out of boundary case</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>+=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>j</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>+=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=c1># the problem case will be dp[m][n] where is the bottom-right cell</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span></code></pre></div><h2 id=iteration-and-inaction-recurrence-relation>Iteration and Inaction Recurrence Relation<a hidden class=anchor aria-hidden=true href=#iteration-and-inaction-recurrence-relation>#</a></h2><p>In some cases, we need to iterate through some possibility to find the optimal solution, like the Coin Change problem we saw in [[#Path and Count DP]].</p><p>Another case is we might need skip the current operation.</p><p>Like <a href=https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/>188. Best Time to Buy and Sell Stock IV</a>, we need decide if we should buy, sell or hold to maximize our gain in the stock.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=c1># Use top-down approach</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>maxProfit</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>k</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>prices</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1># there are three state variables</span>
</span></span><span class=line><span class=cl>		<span class=c1>#  - leftTransactions: how many transactions we can still make</span>
</span></span><span class=line><span class=cl>		<span class=c1>#  - i: the ith day in our trading period</span>
</span></span><span class=line><span class=cl>		<span class=c1>#  - holding: whether we have the stock at our hands</span>
</span></span><span class=line><span class=cl>		<span class=c1># it represnts the max gain we can get given the above state</span>
</span></span><span class=line><span class=cl>        <span class=nd>@cache</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=nf>helper</span><span class=p>(</span><span class=n>leftTransactions</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>holding</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	        <span class=c1># if we cannot make any transactions or pass the trading window, we cannot make any more profit, so the max gain is 0</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>leftTransactions</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>or</span> <span class=n>i</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=n>prices</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>out</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=c1># One choice is we do nothing on ith day, so we could pass our state to the next day</span>
</span></span><span class=line><span class=cl>            <span class=n>out</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>out</span><span class=p>,</span> <span class=n>helper</span><span class=p>(</span><span class=n>leftTransactions</span><span class=p>,</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>holding</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=c1># if we don&#39;t hold the stock, we could choose to buy it on ith day and our gain need subtract the cost of purchase</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>holding</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>out</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>out</span><span class=p>,</span> <span class=o>-</span><span class=n>prices</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>helper</span><span class=p>(</span><span class=n>leftTransactions</span><span class=p>,</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=c1># if we have the stock, we could choose to sell it and the profit will be price on ith day</span>
</span></span><span class=line><span class=cl>            <span class=k>elif</span> <span class=n>holding</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>out</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>out</span><span class=p>,</span> <span class=n>prices</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>helper</span><span class=p>(</span><span class=n>leftTransactions</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>out</span>
</span></span><span class=line><span class=cl>        <span class=c1># thus we should return helper(k, 0, 0) indicating the max gain we can get when we can make k transactions starting day 0 without holding it</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>helper</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=kadanes-algorithm>Kadane&rsquo;s Algorithm<a hidden class=anchor aria-hidden=true href=#kadanes-algorithm>#</a></h2><p>See <a href=https://ihelio.today/posts/2023/coding-pattern-kadanes-algo/>My introduction to Kadane&rsquo;s Algorithm</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=ihelio.today/tags/algorithm/>Algorithm</a></li><li><a href=ihelio.today/tags/leetcode/>LeetCode</a></li></ul><nav class=paginav><a class=prev href=ihelio.today/posts/2023/coding-pattern-kadanes-algo/><span class=title>« Prev</span><br><span>Coding Pattern: Kadane's Algo</span>
</a><a class=next href=ihelio.today/posts/2023/coding-pattern-recursion/><span class=title>Next »</span><br><span>Coding Pattern: Recursion</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Dynamic Programming on x" href="https://x.com/intent/tweet/?text=Coding%20Pattern%3a%20Dynamic%20Programming&amp;url=ihelio.today%2fposts%2f2023%2fcoding-pattern-dynamic-programming%2f&amp;hashtags=Algorithm%2cLeetCode"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Dynamic Programming on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=ihelio.today%2fposts%2f2023%2fcoding-pattern-dynamic-programming%2f&amp;title=Coding%20Pattern%3a%20Dynamic%20Programming&amp;summary=Coding%20Pattern%3a%20Dynamic%20Programming&amp;source=ihelio.today%2fposts%2f2023%2fcoding-pattern-dynamic-programming%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Dynamic Programming on reddit" href="https://reddit.com/submit?url=ihelio.today%2fposts%2f2023%2fcoding-pattern-dynamic-programming%2f&title=Coding%20Pattern%3a%20Dynamic%20Programming"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Dynamic Programming on facebook" href="https://facebook.com/sharer/sharer.php?u=ihelio.today%2fposts%2f2023%2fcoding-pattern-dynamic-programming%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Dynamic Programming on whatsapp" href="https://api.whatsapp.com/send?text=Coding%20Pattern%3a%20Dynamic%20Programming%20-%20ihelio.today%2fposts%2f2023%2fcoding-pattern-dynamic-programming%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Dynamic Programming on telegram" href="https://telegram.me/share/url?text=Coding%20Pattern%3a%20Dynamic%20Programming&amp;url=ihelio.today%2fposts%2f2023%2fcoding-pattern-dynamic-programming%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Dynamic Programming on ycombinator" href="https://news.ycombinator.com/submitlink?t=Coding%20Pattern%3a%20Dynamic%20Programming&u=ihelio.today%2fposts%2f2023%2fcoding-pattern-dynamic-programming%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//ihelio-today.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2025 <a href=ihelio.today/>iHelio</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>