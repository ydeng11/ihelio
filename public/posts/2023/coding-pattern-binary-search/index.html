<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Coding Pattern: Binary Search | iHelio</title>
<meta name="keywords" content="">
<meta name="description" content="In one word, binary search is to search for a target in a sorted array. The idea is to shrink the search space to empty. It must be sorted because we can be...">
<meta name="author" content="Me">
<link rel="canonical" href="https://ihelio.today/posts/2023/coding-pattern-binary-search/">
<meta name="google-site-verification" content="XYZabc">
<meta name="yandex-verification" content="XYZabc">
<meta name="msvalidate.01" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.2211ca3164be7830024f6aad2b3a2e520843a64f8f048445c3401c1249aa051d.css" integrity="sha256-IhHKMWS&#43;eDACT2qtKzouUghDpk&#43;PBIRFw0AcEkmqBR0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ihelio.today/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="https://ihelio.today/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="https://ihelio.today/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="https://ihelio.today/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="https://ihelio.today/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://ihelio.today/posts/2023/coding-pattern-binary-search/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-R4SSGN5Y2Z"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-R4SSGN5Y2Z');
        }
      </script><meta property="og:url" content="https://ihelio.today/posts/2023/coding-pattern-binary-search/">
  <meta property="og:site_name" content="iHelio">
  <meta property="og:title" content="Coding Pattern: Binary Search">
  <meta property="og:description" content="In one word, binary search is to search for a target in a sorted array. The idea is to shrink the search space to empty. It must be sorted because we can be...">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-10-08T16:28:21-04:00">
    <meta property="article:modified_time" content="2023-10-08T16:28:21-04:00">
      <meta property="og:image" content="https://ihelio.today/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://ihelio.today/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name="twitter:title" content="Coding Pattern: Binary Search">
<meta name="twitter:description" content="In one word, binary search is to search for a target in a sorted array. The idea is to shrink the search space to empty. It must be sorted because we can be...">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://ihelio.today/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Coding Pattern: Binary Search",
      "item": "https://ihelio.today/posts/2023/coding-pattern-binary-search/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Coding Pattern: Binary Search",
  "name": "Coding Pattern: Binary Search",
  "description": "In one word, binary search is to search for a target in a sorted array. The idea is to shrink the search space to empty. It must be sorted because we can be...",
  "keywords": [
    
  ],
  "articleBody": "Overview In one word, binary search is to search for a target in a sorted array. The idea is to shrink the search space to empty.\nIt must be sorted because we can be sure how to shrink the search space and we normally reduce the search space by half so the time complexity is O(logN) where N is the size of entire search space.\nOne common problem to understand Binary Search is how to identify the boundary of the search space.\nThe below is the pattern I am using to solve the most Binary Search questions.\nclass Solution: def search(self, nums: List[int], target: int) -\u003e int: # The boundary is inclusive which determines the while condition head, tail = 0, len(nums) - 1 # since the boundary is inclusive on the two ends of the nums array # we should search even when head == tail and we should just check # that particular value while head \u003c= tail: # we use floor division to make sure mid is an integer otherwise # it cannot be used to index # and using floor division will always result in a smaller value # towards head so we don't want to stop search when head \u003c tail mid = (head + tail) // 2 # this is the part I love about this approach # we can return the result right away if it is equal to the target as # 1: we don't have to go through all search space # 2: we can safely eliminate mid point in the next search if nums[mid] == target: return mid # if target is larger than nums[mid], it indicates the result sits # on the left of mid, and otherwise the result sits on the right if nums[mid] \u003c target: # since we are sure nums[mid] is not the result, we don't have # to check nums[mid] again and we could move head to mid + 1 # otherwise, we move tail to mid - 1 head = mid + 1 else: tail = mid - 1 # we are sure no results are found since all space are searched return -1 Example Questions 69. Sqrt(x)\nGiven a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\nYou must not use any built-in exponent function or operator.\nFor example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python. Example 1:\nInput: x = 4 Output: 2 Explanation: The square root of 4 is 2, so we return 2.\nExample 2:\nInput: x = 8 Output: 2 Explanation: The square root of 8 is 2.82842…, and since we round it down to the nearest integer, 2 is returned.\nConstraints:\n0 \u003c= x \u003c= 231 - 1 Solution:\nclass Solution: # we are using binary search because the search space is sorted and must be # from [1, x] def mySqrt(self, x: int) -\u003e int: if x \u003c 2: return x # The search space is [0, x//2] since it is to find the square root head, tail = 0, x // 2 while head \u003c= tail: mid = (head + tail) // 2 temp = mid * mid if temp == x: return mid elif temp \u003c x: head = mid + 1 else: tail = mid - 1 if mid * mid \u003e x: return mid - 1 else: return mid 33. Search in Rotated Sorted Array\nThere is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 \u003c= k \u003c nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0 Output: 4\nExample 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3 Output: -1\nExample 3:\nInput: nums = [1], target = 0 Output: -1\nConstraints:\n1 \u003c= nums.length \u003c= 5000 -104 \u003c= nums[i] \u003c= 104 All values of nums are unique. nums is an ascending array that is possibly rotated. -104 \u003c= target \u003c= 104 Solution\nclass Solution: def search(self, nums: list[int], target: int) -\u003e int: head = 0 tail = len(nums) - 1 while head \u003c= tail: mid = (head + tail) // 2 if nums[mid] == target: return mid if nums[head] \u003c= nums[mid]: if nums[head] \u003c= target \u003c= nums[mid]: tail = mid - 1 else: head = mid + 1 else: if nums[mid] \u003c= target \u003c= nums[tail]: head = mid + 1 else: tail = mid - 1 return -1 4. Median of Two Sorted Arrays\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\nExample 1:\nInput: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2.\nExample 2:\nInput: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\nConstraints:\nnums1.length == m nums2.length == n 0 \u003c= m \u003c= 1000 0 \u003c= n \u003c= 1000 1 \u003c= m + n \u003c= 2000 -106 \u003c= nums1[i], nums2[i] \u003c= 106 Solution:\nThis question has the following information:\ntwo sorted arrays find the median of the two sorted arrays which indicate the non-descending order time complexity is O(log(m+n)) which is a big sign of Binary Search The idea is to find the slice, say mid1 and mid2, in two arrays and nums1[mid1] \u003c nums2[mid2] and nums2[mid2] \u003c nums1[mid1] so we know the elements on the left of mid1 and mid2 are smaller than the elements on the other side. Then we could get the median based on the size of the total elements.\nAnd one key in this question is to make sure all the elements on the left add up should be equal to the half size of entire elements, then we can ensure the mid1 and mid2 represent the position of median values.\nclass Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -\u003e float: if len(nums1) \u003e len(nums2): return self.findMedianSortedArrays(nums2, nums1) m, n = len(nums1), len(nums2) # the search space is the length of the array unlike the index in above questions, this is important since the array is 0-indexed. head, tail = 0, m while head \u003c= tail: # this the length we attempt to grap from nums1 mid1 = (head + tail) // 2 # this is the length we attempt to grap from nums2, it is (m + n + 1)//2 - mid1 so mid2 will not be negative # when mid1 increases and equal to m, (m + n)//2 - m could be negative when n \u003c m and (m + n) is odd, thus (m + n + 1) ensure mid2 won't be negative mid2 = (m + n + 1) // 2 - mid1 # if the length is 0 for either nums1 or nums2, the value on the left should be infinite negative since there is no value maxLeft1 = float(\"-inf\") if mid1 == 0 else nums1[mid1 - 1] maxLeft2 = float(\"-inf\") if mid2 == 0 else nums2[mid2 - 1] # likewise, if entire elements are grapped, the element on the right is infinite positive minRight1 = float(\"inf\") if mid1 == m else nums1[mid1] minRight2 = float(\"inf\") if mid2 == n else nums2[mid2] # since we get mid2 from mid1 and the total length, the mid1 and mid2 should always slice the entire elements into half and we only need check if the elements to the left of mid1 and mid2 are less than those on the other side. if maxLeft1 \u003c= minRight2 and maxLeft2 \u003c= minRight1: # if so, we calculate the median given the total size if (m + n) % 2 == 0: # if it is even, we need the value on the left and right of mid since it requires two value return (min(minRight1, minRight2) + max(maxLeft1, maxLeft2)) / 2 else: # otherwise, we only need the max of maxLeft1 and maxLeft2 return max(maxLeft1, maxLeft2) else: # if the ending condition doesn't meet, we should adjust the search space to contain less elements from nums1 since the left value of mid1, maxLeft1, is larger than the right value of mid2, minRight2 if maxLeft1 \u003e minRight2: tail = mid1 - 1 else: head = mid1 + 1 1891. Cutting Ribbons\nYou are given an integer array ribbons, where ribbons[i] represents the length of the ith ribbon, and an integer k. You may cut any of the ribbons into any number of segments of positive integer lengths, or perform no cuts at all.\nFor example, if you have a ribbon of length 4, you can: Keep the ribbon of length 4, Cut it into one ribbon of length 3 and one ribbon of length 1, Cut it into two ribbons of length 2, Cut it into one ribbon of length 2 and two ribbons of length 1, or Cut it into four ribbons of length 1. Your goal is to obtain k ribbons of all the same positive integer length. You are allowed to throw away any excess ribbon as a result of cutting.\nReturn the maximum possible positive integer length that you can obtain k ribbons of_, or_ 0 if you cannot obtain k ribbons of the same length.\nExample 1:\nInput: ribbons = [9,7,5], k = 3 Output: 5 Explanation:\nCut the first ribbon to two ribbons, one of length 5 and one of length 4. Cut the second ribbon to two ribbons, one of length 5 and one of length 2. Keep the third ribbon as it is. Now you have 3 ribbons of length 5. Example 2:\nInput: ribbons = [7,5,9], k = 4 Output: 4 Explanation:\nCut the first ribbon to two ribbons, one of length 4 and one of length 3. Cut the second ribbon to two ribbons, one of length 4 and one of length 1. Cut the third ribbon to three ribbons, two of length 4 and one of length 1. Now you have 4 ribbons of length 4. Example 3:\nInput: ribbons = [5,7,9], k = 22 Output: 0 Explanation: You cannot obtain k ribbons of the same positive integer length.\nConstraints:\n1 \u003c= ribbons.length \u003c= 105 1 \u003c= ribbons[i] \u003c= 105 1 \u003c= k \u003c= 109 Solution:\nThis question asks if we could find a maximum possible length to cut the ribbons into k ribbons of the same size.\nTherefore, we know it is a search question between the minimal length, 1, and the maximal length, the longest ribbon given.\nAnd we want to have the maximum possible length of each cut. Suppose we have length A which yields more than k ribbons, we should try a larger value and otherwise a lesser value.\nThe only difference with above questions is we have to go through the entire search space. And we are trying to find the maximal value, in our pattern, we should return $tail$ (the right end of search space) in the end.\nclass Solution: def maxLength(self, ribbons: List[int], k: int) -\u003e int: # set the two end of search space head, tail = 1, max(ribbons) # check how many ribbons can be made def helper(cut): count = 0 for ribbon in ribbons: count += ribbon // cut return count while head \u003c= tail: mid = (head + tail) // 2 # if we get more than k rippons, we could try a larger value if helper(mid) \u003e= k: head = mid + 1 else: tail = mid - 1 # here we return tail instead of mid # In one word, the search space will be between two values at the end # suppose head = 4 and tail = 5, so mid = 4 due to floor division, then we have two scenarios 4 is the answer and 4 is not the answer. But no matter what, we will make head = mid + 1 = 5 (since 4 will def generate k or more than k rippons, otherwise the head won't be 4 at the last round). # When head = 5, the mid = 5 #if 5 is not the answer, tail will become mid - 1 = 4 and we finish search #if 5 is the answer, head = mid + 1 = 6 \u003e tail = 5, we also finish search # thus we should return tail as the result return tail Takeaways In my opinion, *Binary Search* is a possible solution when the questions contain the following information: 1. The question asks us to find an result and this results are comparable with each other so we could shrink the search space 2. The search space must be sorted 3. We also need pay attention to the final result (tail or mid) In this case, as long as we can transform the question into the case above, we could use *Binary Search* to solve it. ",
  "wordCount" : "2233",
  "inLanguage": "en",
  "image": "https://ihelio.today/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished": "2023-10-08T16:28:21-04:00",
  "dateModified": "2023-10-08T16:28:21-04:00",
  "author":{
    "@type": "Person",
    "name": "Me"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ihelio.today/posts/2023/coding-pattern-binary-search/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "iHelio",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ihelio.today/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ihelio.today/" accesskey="h" title="Home (Alt + H)">
                <img src="https://ihelio.today/apple-touch-icon.png" alt="" aria-label="logo"
                    height="35">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ihelio.today/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://ihelio.today/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://ihelio.today/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://ihelio.today/">Home</a>&nbsp;»&nbsp;<a href="https://ihelio.today/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Coding Pattern: Binary Search
    </h1>
    
    <div class="post-meta"><span title='2023-10-08 16:28:21 -0400 EDT'>October 8, 2023</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2233 words&nbsp;·&nbsp;Me

</div>
  </header> 
  <div class="post-content"><h2 id="overview">Overview<a hidden class="anchor" aria-hidden="true" href="#overview">#</a></h2>
<p>In one word, binary search is to search for a target in a sorted array. The idea is to shrink the search space to empty.</p>
<p>It must be sorted because we can be sure how to shrink the search space and we normally reduce the search space by half so the time complexity is <code>O(logN)</code> where <code>N</code> is the size of entire search space.</p>
<p>One common problem to understand <em>Binary Search</em> is how to identify the boundary of the search space.</p>
<p>The below is the pattern I am using to solve the most <em>Binary Search</em> questions.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1"># The boundary is inclusive which determines the while condition</span>
</span></span><span class="line"><span class="cl">		<span class="n">head</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="c1"># since the boundary is inclusive on the two ends of the nums array</span>
</span></span><span class="line"><span class="cl">		<span class="c1"># we should search even when head == tail and we should just check </span>
</span></span><span class="line"><span class="cl">		<span class="c1"># that particular value</span>
</span></span><span class="line"><span class="cl">		<span class="k">while</span> <span class="n">head</span> <span class="o">&lt;=</span> <span class="n">tail</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="c1"># we use floor division to make sure mid is an integer otherwise</span>
</span></span><span class="line"><span class="cl">			<span class="c1"># it cannot be used to index</span>
</span></span><span class="line"><span class="cl">			<span class="c1"># and using floor division will always result in a smaller value</span>
</span></span><span class="line"><span class="cl">			<span class="c1"># towards head so we don&#39;t want to stop search when head &lt; tail </span>
</span></span><span class="line"><span class="cl">			<span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">head</span> <span class="o">+</span> <span class="n">tail</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">			<span class="c1"># this is the part I love about this approach</span>
</span></span><span class="line"><span class="cl">			<span class="c1"># we can return the result right away if it is equal to the target as</span>
</span></span><span class="line"><span class="cl">			<span class="c1"># 1: we don&#39;t have to go through all search space</span>
</span></span><span class="line"><span class="cl">			<span class="c1"># 2: we can safely eliminate mid point in the next search</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span> <span class="n">mid</span>
</span></span><span class="line"><span class="cl">			<span class="c1"># if target is larger than nums[mid], it indicates the result sits</span>
</span></span><span class="line"><span class="cl">			<span class="c1"># on the left of mid, and otherwise the result sits on the right</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="c1"># since we are sure nums[mid] is not the result, we don&#39;t have</span>
</span></span><span class="line"><span class="cl">				<span class="c1"># to check nums[mid] again and we could move head to mid + 1</span>
</span></span><span class="line"><span class="cl">				<span class="c1"># otherwise, we move tail to mid - 1</span>
</span></span><span class="line"><span class="cl">				<span class="n">head</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">			<span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="n">tail</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">		<span class="c1"># we are sure no results are found since all space are searched</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span></code></pre></div><h2 id="example-questions">Example Questions<a hidden class="anchor" aria-hidden="true" href="#example-questions">#</a></h2>
<p><a href="https://leetcode.com/problems/sqrtx/">69. Sqrt(x)</a></p>
<p>Given a non-negative integer <code>x</code>, return <em>the square root of</em> <code>x</code> <em>rounded down to the nearest integer</em>. The returned integer should be <strong>non-negative</strong> as well.</p>
<p>You <strong>must not use</strong> any built-in exponent function or operator.</p>
<ul>
<li>For example, do not use <code>pow(x, 0.5)</code> in c++ or <code>x ** 0.5</code> in python.</li>
</ul>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> x = 4
<strong>Output:</strong> 2
<strong>Explanation:</strong> The square root of 4 is 2, so we return 2.</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> x = 8
<strong>Output:</strong> 2
<strong>Explanation:</strong> The square root of 8 is 2.82842&hellip;, and since we round it down to the nearest integer, 2 is returned.</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>0 &lt;= x &lt;= 231 - 1</code></li>
</ul>
<p>Solution:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="c1"># we are using binary search because the search space is sorted and must be</span>
</span></span><span class="line"><span class="cl">	<span class="c1"># from [1, x]</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">mySqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span> <span class="k">return</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># The search space is [0, x//2] since it is to find the square root</span>
</span></span><span class="line"><span class="cl">        <span class="n">head</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">//</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="n">head</span> <span class="o">&lt;=</span> <span class="n">tail</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">head</span> <span class="o">+</span> <span class="n">tail</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">            <span class="n">temp</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">*</span> <span class="n">mid</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">temp</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">mid</span>
</span></span><span class="line"><span class="cl">            <span class="k">elif</span> <span class="n">temp</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">head</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">tail</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">mid</span> <span class="o">*</span> <span class="n">mid</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">mid</span>
</span></span></code></pre></div><p><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/">33. Search in Rotated Sorted Array</a></p>
<p>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</p>
<p>Prior to being passed to your function, <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.</p>
<p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of</em> <code>target</code> <em>if it is in</em> <code>nums</code><em>, or</em> <code>-1</code> <em>if it is not in</em> <code>nums</code>.</p>
<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 0
<strong>Output:</strong> 4</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 3
<strong>Output:</strong> -1</p>
<p><strong>Example 3:</strong></p>
<p><strong>Input:</strong> nums = [1], target = 0
<strong>Output:</strong> -1</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5000</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li>All values of <code>nums</code> are <strong>unique</strong>.</li>
<li><code>nums</code> is an ascending array that is possibly rotated.</li>
<li><code>-104 &lt;= target &lt;= 104</code></li>
</ul>
<p>Solution</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">search</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="n">head</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">        <span class="n">tail</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="n">head</span> <span class="o">&lt;=</span> <span class="n">tail</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">head</span> <span class="o">+</span> <span class="n">tail</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="n">mid</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">target</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">tail</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">head</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">target</span> <span class="o">&lt;=</span> <span class="n">nums</span><span class="p">[</span><span class="n">tail</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">head</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">tail</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</span></span></code></pre></div><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">4. Median of Two Sorted Arrays</a></p>
<p>Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return <strong>the median</strong> of the two sorted arrays.</p>
<p>The overall run time complexity should be <code>O(log (m+n))</code>.</p>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> nums1 = [1,3], nums2 = [2]
<strong>Output:</strong> 2.00000
<strong>Explanation:</strong> merged array = [1,2,3] and median is 2.</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> nums1 = [1,2], nums2 = [3,4]
<strong>Output:</strong> 2.50000
<strong>Explanation:</strong> merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>nums1.length == m</code></li>
<li><code>nums2.length == n</code></li>
<li><code>0 &lt;= m &lt;= 1000</code></li>
<li><code>0 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= m + n &lt;= 2000</code></li>
<li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li>
</ul>
<p>Solution:</p>
<p>This question has the following information:</p>
<ol>
<li>two <strong>sorted</strong> arrays</li>
<li>find the median of the two sorted arrays which indicate the non-descending order</li>
<li>time complexity is <code>O(log(m+n))</code> which is a big sign of <em>Binary Search</em></li>
</ol>
<p>The idea is to find the slice, say <code>mid1</code> and <code>mid2</code>, in two arrays and <code>nums1[mid1] &lt; nums2[mid2]</code> and <code>nums2[mid2] &lt; nums1[mid1]</code> so we know the elements on the left of <code>mid1</code> and <code>mid2</code> are smaller than the elements on the other side. Then we could get the median based on the size of the total elements.</p>
<p>And one key in this question is to make sure all the elements on the left add up should be equal to the half size of entire elements, then we can ensure the <code>mid1</code> and <code>mid2</code> represent the position of median values.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">findMedianSortedArrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums1</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">nums2</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">findMedianSortedArrays</span><span class="p">(</span><span class="n">nums2</span><span class="p">,</span> <span class="n">nums1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># the search space is the length of the array unlike the index in above questions, this is important since the array is 0-indexed.</span>
</span></span><span class="line"><span class="cl">        <span class="n">head</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="n">head</span> <span class="o">&lt;=</span> <span class="n">tail</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	        <span class="c1"># this the length we attempt to grap from nums1</span>
</span></span><span class="line"><span class="cl">            <span class="n">mid1</span> <span class="o">=</span> <span class="p">(</span><span class="n">head</span> <span class="o">+</span> <span class="n">tail</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">			<span class="c1"># this is the length we attempt to grap from nums2, it is (m + n + 1)//2 - mid1 so mid2 will not be negative</span>
</span></span><span class="line"><span class="cl">			<span class="c1"># when mid1 increases and equal to m, (m + n)//2 - m could be negative when n &lt; m and (m + n) is odd, thus (m + n + 1) ensure mid2 won&#39;t be negative</span>
</span></span><span class="line"><span class="cl">            <span class="n">mid2</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">mid1</span>
</span></span><span class="line"><span class="cl">			<span class="c1"># if the length is 0 for either nums1 or nums2, the value on the left should be infinite negative since there is no value</span>
</span></span><span class="line"><span class="cl">            <span class="n">maxLeft1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&#34;-inf&#34;</span><span class="p">)</span> <span class="k">if</span> <span class="n">mid1</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">nums1</span><span class="p">[</span><span class="n">mid1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="n">maxLeft2</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&#34;-inf&#34;</span><span class="p">)</span> <span class="k">if</span> <span class="n">mid2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">nums2</span><span class="p">[</span><span class="n">mid2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">			<span class="c1"># likewise, if entire elements are grapped, the element on the right is infinite positive</span>
</span></span><span class="line"><span class="cl">            <span class="n">minRight1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&#34;inf&#34;</span><span class="p">)</span> <span class="k">if</span> <span class="n">mid1</span> <span class="o">==</span> <span class="n">m</span> <span class="k">else</span> <span class="n">nums1</span><span class="p">[</span><span class="n">mid1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="n">minRight2</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&#34;inf&#34;</span><span class="p">)</span> <span class="k">if</span> <span class="n">mid2</span> <span class="o">==</span> <span class="n">n</span> <span class="k">else</span> <span class="n">nums2</span><span class="p">[</span><span class="n">mid2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">			<span class="c1"># since we get mid2 from mid1 and the total length, the mid1 and mid2 should always slice the entire elements into half and we only need check if the elements to the left of mid1 and mid2 are less than those on the other side.</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">maxLeft1</span> <span class="o">&lt;=</span> <span class="n">minRight2</span> <span class="ow">and</span> <span class="n">maxLeft2</span> <span class="o">&lt;=</span> <span class="n">minRight1</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	            <span class="c1"># if so, we calculate the median given the total size</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	                <span class="c1"># if it is even, we need the value on the left and right of mid since it requires two value</span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">minRight1</span><span class="p">,</span> <span class="n">minRight2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxLeft1</span><span class="p">,</span> <span class="n">maxLeft2</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	                <span class="c1"># otherwise, we only need the max of maxLeft1 and maxLeft2 </span>
</span></span><span class="line"><span class="cl">                    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxLeft1</span><span class="p">,</span> <span class="n">maxLeft2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	            <span class="c1"># if the ending condition doesn&#39;t meet, we should adjust the search space to contain less elements from nums1 since the left value of mid1, maxLeft1, is larger than the right value of mid2, minRight2</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span> <span class="n">maxLeft1</span> <span class="o">&gt;</span> <span class="n">minRight2</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">tail</span> <span class="o">=</span> <span class="n">mid1</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">                <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                    <span class="n">head</span> <span class="o">=</span> <span class="n">mid1</span> <span class="o">+</span> <span class="mi">1</span>
</span></span></code></pre></div><p><a href="https://leetcode.com/problems/cutting-ribbons/">1891. Cutting Ribbons</a></p>
<p>You are given an integer array <code>ribbons</code>, where <code>ribbons[i]</code> represents the length of the <code>ith</code> ribbon, and an integer <code>k</code>. You may cut any of the ribbons into any number of segments of <strong>positive integer</strong> lengths, or perform no cuts at all.</p>
<ul>
<li>For example, if you have a ribbon of length <code>4</code>, you can:
<ul>
<li>Keep the ribbon of length <code>4</code>,</li>
<li>Cut it into one ribbon of length <code>3</code> and one ribbon of length <code>1</code>,</li>
<li>Cut it into two ribbons of length <code>2</code>,</li>
<li>Cut it into one ribbon of length <code>2</code> and two ribbons of length <code>1</code>, or</li>
<li>Cut it into four ribbons of length <code>1</code>.</li>
</ul>
</li>
</ul>
<p>Your goal is to obtain <code>k</code> ribbons of all the <strong>same positive integer length</strong>. You are allowed to throw away any excess ribbon as a result of cutting.</p>
<p>Return <em>the <strong>maximum</strong> possible positive integer length that you can obtain</em> <code>k</code> <em>ribbons of</em>_, or_ <code>0</code> <em>if you cannot obtain</em> <code>k</code> <em>ribbons of the same length</em>.</p>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> ribbons = [9,7,5], k = 3
<strong>Output:</strong> 5
<strong>Explanation:</strong></p>
<ul>
<li>Cut the first ribbon to two ribbons, one of length 5 and one of length 4.</li>
<li>Cut the second ribbon to two ribbons, one of length 5 and one of length 2.</li>
<li>Keep the third ribbon as it is.
Now you have 3 ribbons of length 5.</li>
</ul>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> ribbons = [7,5,9], k = 4
<strong>Output:</strong> 4
<strong>Explanation:</strong></p>
<ul>
<li>Cut the first ribbon to two ribbons, one of length 4 and one of length 3.</li>
<li>Cut the second ribbon to two ribbons, one of length 4 and one of length 1.</li>
<li>Cut the third ribbon to three ribbons, two of length 4 and one of length 1.
Now you have 4 ribbons of length 4.</li>
</ul>
<p><strong>Example 3:</strong></p>
<p><strong>Input:</strong> ribbons = [5,7,9], k = 22
<strong>Output:</strong> 0
<strong>Explanation:</strong> You cannot obtain k ribbons of the same positive integer length.</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= ribbons.length &lt;= 105</code></li>
<li><code>1 &lt;= ribbons[i] &lt;= 105</code></li>
<li><code>1 &lt;= k &lt;= 109</code></li>
</ul>
<p>Solution:</p>
<p>This question asks if we could find a maximum possible length to cut the ribbons into <code>k</code> ribbons of the same size.</p>
<p>Therefore, we know it is a search question between the minimal length, 1, and the maximal length, the longest ribbon given.</p>
<p>And we want to have the maximum possible length of each cut. Suppose we have length <code>A</code> which yields more than <code>k</code> ribbons, we should try a larger value and otherwise a lesser value.</p>
<p><strong>The only difference with above questions is we have to go through the entire search space.</strong> And we are trying to find the maximal value, in our pattern, we should return $tail$ (the right end of search space) in the end.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">maxLength</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ribbons</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	    <span class="c1"># set the two end of search space</span>
</span></span><span class="line"><span class="cl">        <span class="n">head</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ribbons</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="c1"># check how many ribbons can be made</span>
</span></span><span class="line"><span class="cl">        <span class="k">def</span> <span class="nf">helper</span><span class="p">(</span><span class="n">cut</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">ribbon</span> <span class="ow">in</span> <span class="n">ribbons</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">count</span> <span class="o">+=</span> <span class="n">ribbon</span> <span class="o">//</span> <span class="n">cut</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">count</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="n">head</span> <span class="o">&lt;=</span> <span class="n">tail</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">head</span> <span class="o">+</span> <span class="n">tail</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl">            <span class="c1"># if we get more than k rippons, we could try a larger value</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="n">helper</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">head</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">            <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">tail</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># here we return tail instead of mid</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># In one word, the search space will be between two values at the end </span>
</span></span><span class="line"><span class="cl">        <span class="c1"># suppose head = 4 and tail = 5, so mid = 4 due to floor division, then we have two scenarios 4 is the answer and 4 is not the answer. But no matter what, we will make head = mid + 1 = 5 (since 4 will def generate k or more than k rippons, otherwise the head won&#39;t be 4 at the last round). </span>
</span></span><span class="line"><span class="cl">        <span class="c1"># When head = 5, the mid = 5</span>
</span></span><span class="line"><span class="cl">	        <span class="c1">#if 5 is not the answer, tail will become mid - 1 = 4 and we finish search</span>
</span></span><span class="line"><span class="cl">	        <span class="c1">#if 5 is the answer, head = mid + 1 = 6 &gt; tail = 5, we also finish search</span>
</span></span><span class="line"><span class="cl">	    <span class="c1"># thus we should return tail as the result   </span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">tail</span>
</span></span></code></pre></div><h4 id="takeaways">Takeaways<a hidden class="anchor" aria-hidden="true" href="#takeaways">#</a></h4>
<pre tabindex="0"><code class="language-ad-hint" data-lang="ad-hint">In my opinion, *Binary Search* is a possible solution when the questions contain the following information:
1. The question asks us to find an result and this results are comparable with each other so we could shrink the search space
2. The search space must be sorted
3. We also need pay attention to the final result (tail or mid)

In this case, as long as we can transform the question into the case above, we could use *Binary Search* to solve it.
</code></pre>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://ihelio.today/posts/2023/coding-pattern-divide-conquer/">
    <span class="title">« Prev</span>
    <br>
    <span>Coding Pattern: Divide &amp; Conquer</span>
  </a>
  <a class="next" href="https://ihelio.today/posts/2023/build-a-home-media-server-but-automated/">
    <span class="title">Next »</span>
    <br>
    <span>Build a home media server but automated</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Binary Search on x"
            href="https://x.com/intent/tweet/?text=Coding%20Pattern%3a%20Binary%20Search&amp;url=https%3a%2f%2fihelio.today%2fposts%2f2023%2fcoding-pattern-binary-search%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Binary Search on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fihelio.today%2fposts%2f2023%2fcoding-pattern-binary-search%2f&amp;title=Coding%20Pattern%3a%20Binary%20Search&amp;summary=Coding%20Pattern%3a%20Binary%20Search&amp;source=https%3a%2f%2fihelio.today%2fposts%2f2023%2fcoding-pattern-binary-search%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Binary Search on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fihelio.today%2fposts%2f2023%2fcoding-pattern-binary-search%2f&title=Coding%20Pattern%3a%20Binary%20Search">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Binary Search on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fihelio.today%2fposts%2f2023%2fcoding-pattern-binary-search%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Binary Search on whatsapp"
            href="https://api.whatsapp.com/send?text=Coding%20Pattern%3a%20Binary%20Search%20-%20https%3a%2f%2fihelio.today%2fposts%2f2023%2fcoding-pattern-binary-search%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Binary Search on telegram"
            href="https://telegram.me/share/url?text=Coding%20Pattern%3a%20Binary%20Search&amp;url=https%3a%2f%2fihelio.today%2fposts%2f2023%2fcoding-pattern-binary-search%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Binary Search on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Coding%20Pattern%3a%20Binary%20Search&u=https%3a%2f%2fihelio.today%2fposts%2f2023%2fcoding-pattern-binary-search%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer><section class="related-posts">
    <h3>Related Posts</h3>
    <ul class="related-posts-list"><li>
            <a href="/posts/2023/coding-pattern-kadanes-algo/">Coding Pattern: Kadane&#39;s Algo</a>
            <span class="meta">
                &nbsp;&mdash;&nbsp;November 30, 2023
            </span>
        </li><li>
            <a href="/posts/2023/coding-pattern-dynamic-programming/">Coding Pattern: Dynamic Programming</a>
            <span class="meta">
                &nbsp;&mdash;&nbsp;November 30, 2023
            </span>
        </li><li>
            <a href="/posts/2023/coding-pattern-recursion/">Coding Pattern: Recursion</a>
            <span class="meta">
                &nbsp;&mdash;&nbsp;November 5, 2023
            </span>
        </li><li>
            <a href="/posts/2023/coding-pattern-trie/">Coding Pattern: Trie</a>
            <span class="meta">
                &nbsp;&mdash;&nbsp;October 22, 2023
            </span>
        </li><li>
            <a href="/posts/2023/coding-pattern-two-pointers/">Coding Pattern: Two Pointers</a>
            <span class="meta">
                &nbsp;&mdash;&nbsp;October 12, 2023
            </span>
        </li></ul>
</section>
<style>
    .related-posts {
        margin-top: 40px;
        padding-top: 20px;
        border-top: 1px solid var(--border);
    }
    .related-posts h3 {
        margin-bottom: 20px;
    }
    .related-posts-list li {
        margin-bottom: 10px;
    }
</style>
<div id="disqus_thread"></div>
<script type="text/javascript">

(function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    var disqus_shortname = 'ihelio-today';
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://ihelio.today/">iHelio</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
