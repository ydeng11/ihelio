<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Coding Pattern: Trie | iHelio</title>
<meta name="keywords" content="">
<meta name="description" content="Overview
The union-find algorithm is a data structure and algorithm that maintains a collection of disjoint sets. A disjoint set is a set of elements that are not connected to each other. The union-find algorithm can be used to perform the following operations:

Find: Find the set that an element belongs to.
Union: Merge two sets together.

The union-find algorithm is often used to solve problems that involve graph connectivity. For example, the union-find algorithm can be used to determine whether two nodes in a graph are connected, or to find all of the connected components in a graph.">
<meta name="author" content="Me">
<link rel="canonical" href="/posts/2023/coding-pattern-trie/">
<meta name="google-site-verification" content="XYZabc">
<meta name="yandex-verification" content="XYZabc">
<meta name="msvalidate.01" content="XYZabc">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="16x16" href="/%3Clink%20/%20abs%20url%3E">
<link rel="icon" type="image/png" sizes="32x32" href="/%3Clink%20/%20abs%20url%3E">
<link rel="apple-touch-icon" href="/%3Clink%20/%20abs%20url%3E">
<link rel="mask-icon" href="/%3Clink%20/%20abs%20url%3E">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="/posts/2023/coding-pattern-trie/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-R4SSGN5Y2Z"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-R4SSGN5Y2Z');
        }
      </script><meta property="og:url" content="/posts/2023/coding-pattern-trie/">
  <meta property="og:site_name" content="iHelio">
  <meta property="og:title" content="Coding Pattern: Trie">
  <meta property="og:description" content="Overview The union-find algorithm is a data structure and algorithm that maintains a collection of disjoint sets. A disjoint set is a set of elements that are not connected to each other. The union-find algorithm can be used to perform the following operations:
Find: Find the set that an element belongs to. Union: Merge two sets together. The union-find algorithm is often used to solve problems that involve graph connectivity. For example, the union-find algorithm can be used to determine whether two nodes in a graph are connected, or to find all of the connected components in a graph.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-10-22T21:41:02-04:00">
    <meta property="article:modified_time" content="2023-10-22T21:41:02-04:00">
      <meta property="og:image" content="/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E">
<meta name="twitter:title" content="Coding Pattern: Trie">
<meta name="twitter:description" content="Overview
The union-find algorithm is a data structure and algorithm that maintains a collection of disjoint sets. A disjoint set is a set of elements that are not connected to each other. The union-find algorithm can be used to perform the following operations:

Find: Find the set that an element belongs to.
Union: Merge two sets together.

The union-find algorithm is often used to solve problems that involve graph connectivity. For example, the union-find algorithm can be used to determine whether two nodes in a graph are connected, or to find all of the connected components in a graph.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "/posts/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Coding Pattern: Trie",
      "item": "/posts/2023/coding-pattern-trie/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Coding Pattern: Trie",
  "name": "Coding Pattern: Trie",
  "description": "Overview The union-find algorithm is a data structure and algorithm that maintains a collection of disjoint sets. A disjoint set is a set of elements that are not connected to each other. The union-find algorithm can be used to perform the following operations:\nFind: Find the set that an element belongs to. Union: Merge two sets together. The union-find algorithm is often used to solve problems that involve graph connectivity. For example, the union-find algorithm can be used to determine whether two nodes in a graph are connected, or to find all of the connected components in a graph.\n",
  "keywords": [
    
  ],
  "articleBody": "Overview The union-find algorithm is a data structure and algorithm that maintains a collection of disjoint sets. A disjoint set is a set of elements that are not connected to each other. The union-find algorithm can be used to perform the following operations:\nFind: Find the set that an element belongs to. Union: Merge two sets together. The union-find algorithm is often used to solve problems that involve graph connectivity. For example, the union-find algorithm can be used to determine whether two nodes in a graph are connected, or to find all of the connected components in a graph.\nHere is an illustrative example of the union-find algorithm:\nImagine that we have a set of 5 elements: A, B, C, D, and E. We can use the union-find algorithm to maintain a collection of disjoint sets of these elements.\nInitially, all of the elements are in their own separate sets:\nSet 1: A Set 2: B Set 3: C Set 4: D Set 5: E Now, let’s say that we want to merge Set 1 and Set 2. We can use the union-find algorithm to do this by combining the two sets into a single set:\nSet 1: A, B Set 3: C Set 4: D Set 5: E We can also use the union-find algorithm to find the set that an element belongs to. For example, if we want to find the set that element B belongs to, we can use the union-find algorithm to determine that B is in Set 1.\nThe union-find algorithm is a powerful tool that can be used to solve a wide variety of problems. It is often used to solve problems that involve graph connectivity, such as finding the connected components in a graph or determining whether two nodes in a graph are connected.\nHere is a diagram that illustrates the union-find algorithm:\nSet 1 / \\ A B \\ / Set 2 In this diagram, Set 1 and Set 2 are merged together. The union-find algorithm maintains a tree structure for each set. The root of the tree is the representative of the set. In this diagram, A is the representative of Set 1 and B is the representative of Set 2.\nTo find the set that an element belongs to, the union-find algorithm follows the pointers from the element to the root of the tree. For example, to find the set that B belongs to, we would follow the pointer from B to A. Since A is the root of the tree, we know that B is in Set 1.\nTo merge two sets together, the union-find algorithm makes the root of one tree the child of the root of the other tree. For example, to merge Set 1 and Set 2, we would make B the child of A. This would create a single tree that represents both Set 1 and Set 2.\nThe union-find algorithm is a very efficient algorithm for maintaining a collection of disjoint sets. It is often used in graph algorithms, such as Kruskal’s algorithm and Prim’s algorithm.\nExample of Implementation class UnionFind: def __init__(self): self.parents = {} self.size = {} def insert(self, x): if x not in self.parents: self.parents[x] = x self.size[x] = 1 # recursively find the uppermost parent node (path compression) def find(self, node): if self.parents[node] != node: self.parents[node] = self.find(self.parents[node]) return self.parents[node] # merge two objects into one set def union(self, x, y): # insert x and y into the parents and size dict self.insert(x) self.insert(y) # find the parent of x and y (union by rank) px, py = self.find(x), self.find(y) # they are already in the same set if their parents are the same if px == py: return # always make px the less parent if self.size[px] \u003e self.size[py]: px, py = py, px # so the parent of px is py since px is less self.parents[px] = py # increase the size of py self.size[py] += self.size[px] Space Complexity: The space complexity for the Union-Find data structure is $O(n)$, where n is the number of elements. This is because, typically, two arrays (or vectors) of size $n$ are maintained: one for parent pointers and another for ranks/sizes.\nTime Complexity: Without optimizations, the operations can be quite slow. However, with the Union by Rank and Path Compression optimizations, the operations become much faster.\nUnion Operation (with Union by Rank): This operation ensures that when two sets are combined, the smaller set (in terms of rank) is attached to the root of the larger set. This keeps the tree relatively flat. This operation is generally $O(1)$ but can be considered $O(logn)$ in the worst case because in the worst case the height of the tree can grow up to $logn$. Find Operation (with Path Compression): When performing a find operation to determine the root of a particular element, the algorithm traverses up the tree and, in the process, flattens the tree by making every node point directly to the root. This makes future find operations faster. The amortized time complexity of the find operation with path compression (and union by rank) is near $O(1)$. However, when considering sequences of operations, the inverse Ackermann function, $α(n)$, often comes into play, making the operations effectively constant time for all practical purposes. Union (combined with Find): Since the union operation often involves two find operations (to get the roots of the two sets being unioned), its time complexity is also governed by the find operation. Thus, its amortized time complexity is also effectively constant for practical purposes, but academically it’s often cited as $O(α(n))$. In summary, with the Union by Rank and Path Compression optimizations, the Union-Find operations become nearly constant time, $O(α(n))$, where $α(n)$ is the inverse Ackermann function, which grows extremely slowly. For most practical purposes, it’s considered constant time.\nExample Questions 721. Accounts Merge Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.\nNow, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.\nAfter merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.\nExample 1:\nInput: accounts = [[“John”,“johnsmith@mail.com”,“john_newyork@mail.com”],[“John”,“johnsmith@mail.com”,“john00@mail.com”],[“Mary”,“mary@mail.com”],[“John”,“johnnybravo@mail.com”]] Output: [[“John”,“john00@mail.com”,“john_newyork@mail.com”,“johnsmith@mail.com”],[“Mary”,“mary@mail.com”],[“John”,“johnnybravo@mail.com”]] Explanation: The first and second John’s are the same person as they have the common email “johnsmith@mail.com”. The third John and Mary are different people as none of their email addresses are used by other accounts. We could return these lists in any order, for example the answer [[‘Mary’, ‘mary@mail.com’], [‘John’, ‘johnnybravo@mail.com’], [‘John’, ‘john00@mail.com’, ‘john_newyork@mail.com’, ‘johnsmith@mail.com’]] would still be accepted.\nExample 2:\nInput: accounts = [[“Gabe”,“Gabe0@m.co”,“Gabe3@m.co”,“Gabe1@m.co”],[“Kevin”,“Kevin3@m.co”,“Kevin5@m.co”,“Kevin0@m.co”],[“Ethan”,“Ethan5@m.co”,“Ethan4@m.co”,“Ethan0@m.co”],[“Hanzo”,“Hanzo3@m.co”,“Hanzo1@m.co”,“Hanzo0@m.co”],[“Fern”,“Fern5@m.co”,“Fern1@m.co”,“Fern0@m.co”]] Output: [[“Ethan”,“Ethan0@m.co”,“Ethan4@m.co”,“Ethan5@m.co”],[“Gabe”,“Gabe0@m.co”,“Gabe1@m.co”,“Gabe3@m.co”],[“Hanzo”,“Hanzo0@m.co”,“Hanzo1@m.co”,“Hanzo3@m.co”],[“Kevin”,“Kevin0@m.co”,“Kevin3@m.co”,“Kevin5@m.co”],[“Fern”,“Fern0@m.co”,“Fern1@m.co”,“Fern5@m.co”]]\nConstraints:\n1 \u003c= accounts.length \u003c= 1000 2 \u003c= accounts[i].length \u003c= 10 1 \u003c= accounts[i][j].length \u003c= 30 accounts[i][0] consists of English letters. accounts[i][j] (for j \u003e 0) is a valid email. Solution class UnionFind: def __init__(self): self.parents = {} self.size = {} def insert(self, x): if x not in self.parents: self.parents[x] = x self.size[x] = 1 def find(self, node): if self.parents[node] != node: self.parents[node] = self.find(self.parents[node]) return self.parents[node] def union(self, x, y): self.insert(x) self.insert(y) px, py = self.find(x), self.find(y) if px == py: return if self.size[px] \u003e self.size[py]: px, py = py, px self.parents[px] = py self.size[py] += self.size[px] class Solution: def accountsMerge(self, accounts: List[List[str]]) -\u003e List[List[str]]: uf = UnionFind() name_map = {} for account in accounts: name, emails = account[0], account[1:] for email in emails: name_map[email] = name # merge all the emails with the first email uf.union(emails[0], email) out = defaultdict(list) for key in uf.parents.keys(): # group all emails based on their parent in union-find out[uf.find(key)].append(key) res = [] for key, val in out.items(): res.append([name_map[key]] + sorted(val)) return res Time Complexity: $O(n)$ where $n$ is the number of emails, it is $n$ because of union-by-rank Space Complexity: $O(n)$\n",
  "wordCount" : "1381",
  "inLanguage": "en",
  "image": "/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished": "2023-10-22T21:41:02-04:00",
  "dateModified": "2023-10-22T21:41:02-04:00",
  "author":{
    "@type": "Person",
    "name": "Me"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/posts/2023/coding-pattern-trie/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "iHelio",
    "logo": {
      "@type": "ImageObject",
      "url": "/%3Clink%20/%20abs%20url%3E"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="Home (Alt + H)">
                <img src="/apple-touch-icon.png" alt="" aria-label="logo"
                    height="35">Home</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="/">Home</a>&nbsp;»&nbsp;<a href="/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Coding Pattern: Trie
    </h1>
    <div class="post-meta"><span title='2023-10-22 21:41:02 -0400 EDT'>October 22, 2023</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1381 words&nbsp;·&nbsp;Me

</div>
  </header> 
  <div class="post-content"><h1 id="overview">Overview<a hidden class="anchor" aria-hidden="true" href="#overview">#</a></h1>
<p>The union-find algorithm is a data structure and algorithm that maintains a collection of disjoint sets. A disjoint set is a set of elements that are not connected to each other. The union-find algorithm can be used to perform the following operations:</p>
<ul>
<li><strong>Find:</strong> Find the set that an element belongs to.</li>
<li><strong>Union:</strong> Merge two sets together.</li>
</ul>
<p>The union-find algorithm is often used to solve problems that involve graph connectivity. For example, the union-find algorithm can be used to determine whether two nodes in a graph are connected, or to find all of the connected components in a graph.</p>
<p>Here is an illustrative example of the union-find algorithm:</p>
<p>Imagine that we have a set of 5 elements: A, B, C, D, and E. We can use the union-find algorithm to maintain a collection of disjoint sets of these elements.</p>
<p>Initially, all of the elements are in their own separate sets:</p>
<pre tabindex="0"><code>Set 1: A
Set 2: B
Set 3: C
Set 4: D
Set 5: E
</code></pre><p>Now, let&rsquo;s say that we want to merge Set 1 and Set 2. We can use the union-find algorithm to do this by combining the two sets into a single set:</p>
<pre tabindex="0"><code>Set 1: A, B
Set 3: C
Set 4: D
Set 5: E
</code></pre><p>We can also use the union-find algorithm to find the set that an element belongs to. For example, if we want to find the set that element B belongs to, we can use the union-find algorithm to determine that B is in Set 1.</p>
<p>The union-find algorithm is a powerful tool that can be used to solve a wide variety of problems. It is often used to solve problems that involve graph connectivity, such as finding the connected components in a graph or determining whether two nodes in a graph are connected.</p>
<p>Here is a diagram that illustrates the union-find algorithm:</p>
<pre tabindex="0"><code>        Set 1
       /    \
      A      B
       \    /
        Set 2
</code></pre><p>In this diagram, Set 1 and Set 2 are merged together. The union-find algorithm maintains a tree structure for each set. The root of the tree is the representative of the set. In this diagram, A is the representative of Set 1 and B is the representative of Set 2.</p>
<p>To find the set that an element belongs to, the union-find algorithm follows the pointers from the element to the root of the tree. For example, to find the set that B belongs to, we would follow the pointer from B to A. Since A is the root of the tree, we know that B is in Set 1.</p>
<p>To merge two sets together, the union-find algorithm makes the root of one tree the child of the root of the other tree. For example, to merge Set 1 and Set 2, we would make B the child of A. This would create a single tree that represents both Set 1 and Set 2.</p>
<p>The union-find algorithm is a very efficient algorithm for maintaining a collection of disjoint sets. It is often used in graph algorithms, such as Kruskal&rsquo;s algorithm and Prim&rsquo;s algorithm.</p>
<h2 id="example-of-implementation">Example of Implementation<a hidden class="anchor" aria-hidden="true" href="#example-of-implementation">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">UnionFind</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">parents</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1"># recursively find the uppermost parent node (path compression)</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">!=</span> <span class="n">node</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1"># merge two objects into one set</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">	    <span class="c1"># insert x and y into the parents and size dict</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># find the parent of x and y (union by rank)</span>
</span></span><span class="line"><span class="cl">        <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># they are already in the same set if their parents are the same</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">px</span> <span class="o">==</span> <span class="n">py</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="c1"># always make px the less parent</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="n">px</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="n">py</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="o">=</span> <span class="n">py</span><span class="p">,</span> <span class="n">px</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># so the parent of px is py since px is less</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="n">px</span><span class="p">]</span> <span class="o">=</span> <span class="n">py</span>
</span></span><span class="line"><span class="cl">        <span class="c1"># increase the size of py</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="n">py</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="n">px</span><span class="p">]</span>
</span></span></code></pre></div><p><strong>Space Complexity</strong>:
The space complexity for the Union-Find data structure is $O(n)$, where n is the number of elements. This is because, typically, two arrays (or vectors) of size $n$ are maintained: one for parent pointers and another for ranks/sizes.</p>
<p><strong>Time Complexity</strong>:
Without optimizations, the operations can be quite slow. However, with the <strong>Union by Rank</strong> and <strong>Path Compression</strong> optimizations, the operations become much faster.</p>
<ul>
<li><strong>Union Operation (with Union by Rank)</strong>: This operation ensures that when two sets are combined, the smaller set (in terms of rank) is attached to the root of the larger set. This keeps the tree relatively flat. This operation is generally $O(1)$ but can be considered $O(logn)$ in the worst case because in the worst case the height of the tree can grow up to $logn$.</li>
<li><strong>Find Operation (with Path Compression)</strong>: When performing a <code>find</code> operation to determine the root of a particular element, the algorithm traverses up the tree and, in the process, flattens the tree by making every node point directly to the root. This makes future <code>find</code> operations faster. The amortized time complexity of the <code>find</code> operation with path compression (and union by rank) is near $O(1)$. However, when considering sequences of operations, the inverse Ackermann function, $α(n)$, often comes into play, making the operations effectively constant time for all practical purposes.</li>
<li><strong>Union (combined with Find)</strong>: Since the union operation often involves two <code>find</code> operations (to get the roots of the two sets being unioned), its time complexity is also governed by the <code>find</code> operation. Thus, its amortized time complexity is also effectively constant for practical purposes, but academically it&rsquo;s often cited as $O(α(n))$.</li>
</ul>
<p>In summary, with the Union by Rank and Path Compression optimizations, the Union-Find operations become nearly constant time, $O(α(n))$, where $α(n)$ is the inverse Ackermann function, which grows extremely slowly. For most practical purposes, <strong>it&rsquo;s considered constant time.</strong></p>
<h1 id="example-questions">Example Questions<a hidden class="anchor" aria-hidden="true" href="#example-questions">#</a></h1>
<h2 id="721-accounts-merge"><a href="https://leetcode.com/problems/accounts-merge/">721. Accounts Merge</a><a hidden class="anchor" aria-hidden="true" href="#721-accounts-merge">#</a></h2>
<p>Given a list of <code>accounts</code> where each element <code>accounts[i]</code> is a list of strings, where the first element <code>accounts[i][0]</code> is a name, and the rest of the elements are <strong>emails</strong> representing emails of the account.</p>
<p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p>
<p>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails <strong>in sorted order</strong>. The accounts themselves can be returned in <strong>any order</strong>.</p>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> accounts = [[&ldquo;John&rdquo;,&ldquo;johnsmith@mail.com&rdquo;,&ldquo;john_newyork@mail.com&rdquo;],[&ldquo;John&rdquo;,&ldquo;johnsmith@mail.com&rdquo;,&ldquo;john00@mail.com&rdquo;],[&ldquo;Mary&rdquo;,&ldquo;mary@mail.com&rdquo;],[&ldquo;John&rdquo;,&ldquo;johnnybravo@mail.com&rdquo;]]
<strong>Output:</strong> [[&ldquo;John&rdquo;,&ldquo;john00@mail.com&rdquo;,&ldquo;john_newyork@mail.com&rdquo;,&ldquo;johnsmith@mail.com&rdquo;],[&ldquo;Mary&rdquo;,&ldquo;mary@mail.com&rdquo;],[&ldquo;John&rdquo;,&ldquo;johnnybravo@mail.com&rdquo;]]
<strong>Explanation:</strong>
The first and second John&rsquo;s are the same person as they have the common email &ldquo;<a href="mailto:johnsmith@mail.com">johnsmith@mail.com</a>&rdquo;.
The third John and Mary are different people as none of their email addresses are used by other accounts.
We could return these lists in any order, for example the answer [[&lsquo;Mary&rsquo;, &lsquo;mary@mail.com&rsquo;], [&lsquo;John&rsquo;, &lsquo;johnnybravo@mail.com&rsquo;],
[&lsquo;John&rsquo;, &lsquo;john00@mail.com&rsquo;, &lsquo;john_newyork@mail.com&rsquo;, &lsquo;johnsmith@mail.com&rsquo;]] would still be accepted.</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> accounts = [[&ldquo;Gabe&rdquo;,&ldquo;Gabe0@m.co&rdquo;,&ldquo;Gabe3@m.co&rdquo;,&ldquo;Gabe1@m.co&rdquo;],[&ldquo;Kevin&rdquo;,&ldquo;Kevin3@m.co&rdquo;,&ldquo;Kevin5@m.co&rdquo;,&ldquo;Kevin0@m.co&rdquo;],[&ldquo;Ethan&rdquo;,&ldquo;Ethan5@m.co&rdquo;,&ldquo;Ethan4@m.co&rdquo;,&ldquo;Ethan0@m.co&rdquo;],[&ldquo;Hanzo&rdquo;,&ldquo;Hanzo3@m.co&rdquo;,&ldquo;Hanzo1@m.co&rdquo;,&ldquo;Hanzo0@m.co&rdquo;],[&ldquo;Fern&rdquo;,&ldquo;Fern5@m.co&rdquo;,&ldquo;Fern1@m.co&rdquo;,&ldquo;Fern0@m.co&rdquo;]]
<strong>Output:</strong> [[&ldquo;Ethan&rdquo;,&ldquo;Ethan0@m.co&rdquo;,&ldquo;Ethan4@m.co&rdquo;,&ldquo;Ethan5@m.co&rdquo;],[&ldquo;Gabe&rdquo;,&ldquo;Gabe0@m.co&rdquo;,&ldquo;Gabe1@m.co&rdquo;,&ldquo;Gabe3@m.co&rdquo;],[&ldquo;Hanzo&rdquo;,&ldquo;Hanzo0@m.co&rdquo;,&ldquo;Hanzo1@m.co&rdquo;,&ldquo;Hanzo3@m.co&rdquo;],[&ldquo;Kevin&rdquo;,&ldquo;Kevin0@m.co&rdquo;,&ldquo;Kevin3@m.co&rdquo;,&ldquo;Kevin5@m.co&rdquo;],[&ldquo;Fern&rdquo;,&ldquo;Fern0@m.co&rdquo;,&ldquo;Fern1@m.co&rdquo;,&ldquo;Fern5@m.co&rdquo;]]</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= accounts.length &lt;= 1000</code></li>
<li><code>2 &lt;= accounts[i].length &lt;= 10</code></li>
<li><code>1 &lt;= accounts[i][j].length &lt;= 30</code></li>
<li><code>accounts[i][0]</code> consists of English letters.</li>
<li><code>accounts[i][j] (for j &gt; 0)</code> is a valid email.</li>
</ul>
<h2 id="solution">Solution<a hidden class="anchor" aria-hidden="true" href="#solution">#</a></h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">UnionFind</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">parents</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">!=</span> <span class="n">node</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">px</span> <span class="o">==</span> <span class="n">py</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="n">px</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="n">py</span><span class="p">]:</span>
</span></span><span class="line"><span class="cl">            <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="o">=</span> <span class="n">py</span><span class="p">,</span> <span class="n">px</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="n">px</span><span class="p">]</span> <span class="o">=</span> <span class="n">py</span>
</span></span><span class="line"><span class="cl">        <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="n">py</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="n">px</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="nf">accountsMerge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">accounts</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
</span></span><span class="line"><span class="cl">        <span class="n">uf</span> <span class="o">=</span> <span class="n">UnionFind</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">name_map</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">accounts</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">            <span class="n">name</span><span class="p">,</span> <span class="n">emails</span> <span class="o">=</span> <span class="n">account</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">account</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span> <span class="n">email</span> <span class="ow">in</span> <span class="n">emails</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="n">name_map</span><span class="p">[</span><span class="n">email</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
</span></span><span class="line"><span class="cl">                <span class="c1"># merge all the emails with the first email</span>
</span></span><span class="line"><span class="cl">                <span class="n">uf</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">emails</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">email</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="n">out</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">uf</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">		    <span class="c1"># group all emails based on their parent in union-find</span>
</span></span><span class="line"><span class="cl">            <span class="n">out</span><span class="p">[</span><span class="n">uf</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">name_map</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">+</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">res</span>
</span></span></code></pre></div><p>Time Complexity: $O(n)$ where $n$ is the number of emails, it is $n$ because of union-by-rank
Space Complexity: $O(n)$</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="/posts/2023/coding-pattern-recursion/">
    <span class="title">« Prev</span>
    <br>
    <span>Coding Pattern: Recursion</span>
  </a>
  <a class="next" href="/posts/2023/coding-pattern-two-pointers/">
    <span class="title">Next »</span>
    <br>
    <span>Coding Pattern: Two Pointers</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Trie on x"
            href="https://x.com/intent/tweet/?text=Coding%20Pattern%3a%20Trie&amp;url=%2fposts%2f2023%2fcoding-pattern-trie%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Trie on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=%2fposts%2f2023%2fcoding-pattern-trie%2f&amp;title=Coding%20Pattern%3a%20Trie&amp;summary=Coding%20Pattern%3a%20Trie&amp;source=%2fposts%2f2023%2fcoding-pattern-trie%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Trie on reddit"
            href="https://reddit.com/submit?url=%2fposts%2f2023%2fcoding-pattern-trie%2f&title=Coding%20Pattern%3a%20Trie">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Trie on facebook"
            href="https://facebook.com/sharer/sharer.php?u=%2fposts%2f2023%2fcoding-pattern-trie%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Trie on whatsapp"
            href="https://api.whatsapp.com/send?text=Coding%20Pattern%3a%20Trie%20-%20%2fposts%2f2023%2fcoding-pattern-trie%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Trie on telegram"
            href="https://telegram.me/share/url?text=Coding%20Pattern%3a%20Trie&amp;url=%2fposts%2f2023%2fcoding-pattern-trie%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Coding Pattern: Trie on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Coding%20Pattern%3a%20Trie&u=%2fposts%2f2023%2fcoding-pattern-trie%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="/">iHelio</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
