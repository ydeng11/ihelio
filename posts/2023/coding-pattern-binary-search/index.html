<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Coding Pattern: Binary Search | iHelio</title>
<meta name=keywords content="Algorithm,LeetCode"><meta name=description content="Overview In one word, binary search is to search for a target in a sorted array. The idea is to shrink the search space to empty.
It must be sorted because we can be sure how to shrink the search space and we normally reduce the search space by half so the time complexity is O(logN) where N is the size of entire search space.
One common problem to understand Binary Search is how to identify the boundary of the search space."><meta name=author content="Me"><link rel=canonical href=https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-binary-search/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/ihelio/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://ydeng11.github.io/ihelio/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://ydeng11.github.io/ihelio/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ydeng11.github.io/ihelio/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ydeng11.github.io/ihelio/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://ydeng11.github.io/ihelio/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-binary-search/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-R4SSGN5Y2Z"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-R4SSGN5Y2Z")}</script><meta property="og:url" content="https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-binary-search/"><meta property="og:site_name" content="iHelio"><meta property="og:title" content="Coding Pattern: Binary Search"><meta property="og:description" content="Overview In one word, binary search is to search for a target in a sorted array. The idea is to shrink the search space to empty.
It must be sorted because we can be sure how to shrink the search space and we normally reduce the search space by half so the time complexity is O(logN) where N is the size of entire search space.
One common problem to understand Binary Search is how to identify the boundary of the search space."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-08T16:28:21-04:00"><meta property="article:modified_time" content="2023-10-08T16:28:21-04:00"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="LeetCode"><meta property="og:image" content="https://ydeng11.github.io/ihelio/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ydeng11.github.io/ihelio/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Coding Pattern: Binary Search"><meta name=twitter:description content="Overview In one word, binary search is to search for a target in a sorted array. The idea is to shrink the search space to empty.
It must be sorted because we can be sure how to shrink the search space and we normally reduce the search space by half so the time complexity is O(logN) where N is the size of entire search space.
One common problem to understand Binary Search is how to identify the boundary of the search space."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ydeng11.github.io/ihelio/posts/"},{"@type":"ListItem","position":2,"name":"Coding Pattern: Binary Search","item":"https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-binary-search/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Coding Pattern: Binary Search","name":"Coding Pattern: Binary Search","description":"Overview In one word, binary search is to search for a target in a sorted array. The idea is to shrink the search space to empty.\nIt must be sorted because we can be sure how to shrink the search space and we normally reduce the search space by half so the time complexity is O(logN) where N is the size of entire search space.\nOne common problem to understand Binary Search is how to identify the boundary of the search space.","keywords":["Algorithm","LeetCode"],"articleBody":"Overview In one word, binary search is to search for a target in a sorted array. The idea is to shrink the search space to empty.\nIt must be sorted because we can be sure how to shrink the search space and we normally reduce the search space by half so the time complexity is O(logN) where N is the size of entire search space.\nOne common problem to understand Binary Search is how to identify the boundary of the search space.\nThe below is the pattern I am using to solve the most Binary Search questions.\nclass Solution: def search(self, nums: List[int], target: int) -\u003e int: # The boundary is inclusive which determines the while condition head, tail = 0, len(nums) - 1 # since the boundary is inclusive on the two ends of the nums array # we should search even when head == tail and we should just check # that particular value while head \u003c= tail: # we use floor division to make sure mid is an integer otherwise # it cannot be used to index # and using floor division will always result in a smaller value # towards head so we don't want to stop search when head \u003c tail mid = (head + tail) // 2 # this is the part I love about this approach # we can return the result right away if it is equal to the target as # 1: we don't have to go through all search space # 2: we can safely eliminate mid point in the next search if nums[mid] == target: return mid # if target is larger than nums[mid], it indicates the result sits # on the left of mid, and otherwise the result sits on the right if nums[mid] \u003c target: # since we are sure nums[mid] is not the result, we don't have # to check nums[mid] again and we could move head to mid + 1 # otherwise, we move tail to mid - 1 head = mid + 1 else: tail = mid - 1 # we are sure no results are found since all space are searched return -1 Example Questions 69. Sqrt(x)\nGiven a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\nYou must not use any built-in exponent function or operator.\nFor example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python. Example 1:\nInput: x = 4 Output: 2 Explanation: The square root of 4 is 2, so we return 2.\nExample 2:\nInput: x = 8 Output: 2 Explanation: The square root of 8 is 2.82842…, and since we round it down to the nearest integer, 2 is returned.\nConstraints:\n0 \u003c= x \u003c= 231 - 1 Solution:\nclass Solution: # we are using binary search because the search space is sorted and must be # from [1, x] def mySqrt(self, x: int) -\u003e int: if x \u003c 2: return x # The search space is [0, x//2] since it is to find the square root head, tail = 0, x // 2 while head \u003c= tail: mid = (head + tail) // 2 temp = mid * mid if temp == x: return mid elif temp \u003c x: head = mid + 1 else: tail = mid - 1 if mid * mid \u003e x: return mid - 1 else: return mid 33. Search in Rotated Sorted Array\nThere is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 \u003c= k \u003c nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0 Output: 4\nExample 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3 Output: -1\nExample 3:\nInput: nums = [1], target = 0 Output: -1\nConstraints:\n1 \u003c= nums.length \u003c= 5000 -104 \u003c= nums[i] \u003c= 104 All values of nums are unique. nums is an ascending array that is possibly rotated. -104 \u003c= target \u003c= 104 Solution\nclass Solution: def search(self, nums: list[int], target: int) -\u003e int: head = 0 tail = len(nums) - 1 while head \u003c= tail: mid = (head + tail) // 2 if nums[mid] == target: return mid if nums[head] \u003c= nums[mid]: if nums[head] \u003c= target \u003c= nums[mid]: tail = mid - 1 else: head = mid + 1 else: if nums[mid] \u003c= target \u003c= nums[tail]: head = mid + 1 else: tail = mid - 1 return -1 4. Median of Two Sorted Arrays\nGiven two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).\nExample 1:\nInput: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2.\nExample 2:\nInput: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\nConstraints:\nnums1.length == m nums2.length == n 0 \u003c= m \u003c= 1000 0 \u003c= n \u003c= 1000 1 \u003c= m + n \u003c= 2000 -106 \u003c= nums1[i], nums2[i] \u003c= 106 Solution:\nThis question has the following information:\ntwo sorted arrays find the median of the two sorted arrays which indicate the non-descending order time complexity is O(log(m+n)) which is a big sign of Binary Search The idea is to find the slice, say mid1 and mid2, in two arrays and nums1[mid1] \u003c nums2[mid2] and nums2[mid2] \u003c nums1[mid1] so we know the elements on the left of mid1 and mid2 are smaller than the elements on the other side. Then we could get the median based on the size of the total elements.\nAnd one key in this question is to make sure all the elements on the left add up should be equal to the half size of entire elements, then we can ensure the mid1 and mid2 represent the position of median values.\nclass Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -\u003e float: if len(nums1) \u003e len(nums2): return self.findMedianSortedArrays(nums2, nums1) m, n = len(nums1), len(nums2) # the search space is the length of the array unlike the index in above questions, this is important since the array is 0-indexed. head, tail = 0, m while head \u003c= tail: # this the length we attempt to grap from nums1 mid1 = (head + tail) // 2 # this is the length we attempt to grap from nums2, it is (m + n + 1)//2 - mid1 so mid2 will not be negative # when mid1 increases and equal to m, (m + n)//2 - m could be negative when n \u003c m and (m + n) is odd, thus (m + n + 1) ensure mid2 won't be negative mid2 = (m + n + 1) // 2 - mid1 # if the length is 0 for either nums1 or nums2, the value on the left should be infinite negative since there is no value maxLeft1 = float(\"-inf\") if mid1 == 0 else nums1[mid1 - 1] maxLeft2 = float(\"-inf\") if mid2 == 0 else nums2[mid2 - 1] # likewise, if entire elements are grapped, the element on the right is infinite positive minRight1 = float(\"inf\") if mid1 == m else nums1[mid1] minRight2 = float(\"inf\") if mid2 == n else nums2[mid2] # since we get mid2 from mid1 and the total length, the mid1 and mid2 should always slice the entire elements into half and we only need check if the elements to the left of mid1 and mid2 are less than those on the other side. if maxLeft1 \u003c= minRight2 and maxLeft2 \u003c= minRight1: # if so, we calculate the median given the total size if (m + n) % 2 == 0: # if it is even, we need the value on the left and right of mid since it requires two value return (min(minRight1, minRight2) + max(maxLeft1, maxLeft2)) / 2 else: # otherwise, we only need the max of maxLeft1 and maxLeft2 return max(maxLeft1, maxLeft2) else: # if the ending condition doesn't meet, we should adjust the search space to contain less elements from nums1 since the left value of mid1, maxLeft1, is larger than the right value of mid2, minRight2 if maxLeft1 \u003e minRight2: tail = mid1 - 1 else: head = mid1 + 1 1891. Cutting Ribbons\nYou are given an integer array ribbons, where ribbons[i] represents the length of the ith ribbon, and an integer k. You may cut any of the ribbons into any number of segments of positive integer lengths, or perform no cuts at all.\nFor example, if you have a ribbon of length 4, you can: Keep the ribbon of length 4, Cut it into one ribbon of length 3 and one ribbon of length 1, Cut it into two ribbons of length 2, Cut it into one ribbon of length 2 and two ribbons of length 1, or Cut it into four ribbons of length 1. Your goal is to obtain k ribbons of all the same positive integer length. You are allowed to throw away any excess ribbon as a result of cutting.\nReturn the maximum possible positive integer length that you can obtain k ribbons of_, or_ 0 if you cannot obtain k ribbons of the same length.\nExample 1:\nInput: ribbons = [9,7,5], k = 3 Output: 5 Explanation:\nCut the first ribbon to two ribbons, one of length 5 and one of length 4. Cut the second ribbon to two ribbons, one of length 5 and one of length 2. Keep the third ribbon as it is. Now you have 3 ribbons of length 5. Example 2:\nInput: ribbons = [7,5,9], k = 4 Output: 4 Explanation:\nCut the first ribbon to two ribbons, one of length 4 and one of length 3. Cut the second ribbon to two ribbons, one of length 4 and one of length 1. Cut the third ribbon to three ribbons, two of length 4 and one of length 1. Now you have 4 ribbons of length 4. Example 3:\nInput: ribbons = [5,7,9], k = 22 Output: 0 Explanation: You cannot obtain k ribbons of the same positive integer length.\nConstraints:\n1 \u003c= ribbons.length \u003c= 105 1 \u003c= ribbons[i] \u003c= 105 1 \u003c= k \u003c= 109 Solution:\nThis question asks if we could find a maximum possible length to cut the ribbons into k ribbons of the same size.\nTherefore, we know it is a search question between the minimal length, 1, and the maximal length, the longest ribbon given.\nAnd we want to have the maximum possible length of each cut. Suppose we have length A which yields more than k ribbons, we should try a larger value and otherwise a lesser value.\nThe only difference with above questions is we have to go through the entire search space. And we are trying to find the maximal value, in our pattern, we should return $tail$ (the right end of search space) in the end.\nclass Solution: def maxLength(self, ribbons: List[int], k: int) -\u003e int: # set the two end of search space head, tail = 1, max(ribbons) # check how many ribbons can be made def helper(cut): count = 0 for ribbon in ribbons: count += ribbon // cut return count while head \u003c= tail: mid = (head + tail) // 2 # if we get more than k rippons, we could try a larger value if helper(mid) \u003e= k: head = mid + 1 else: tail = mid - 1 # here we return tail instead of mid # In one word, the search space will be between two values at the end # suppose head = 4 and tail = 5, so mid = 4 due to floor division, then we have two scenarios 4 is the answer and 4 is not the answer. But no matter what, we will make head = mid + 1 = 5 (since 4 will def generate k or more than k rippons, otherwise the head won't be 4 at the last round). # When head = 5, the mid = 5 #if 5 is not the answer, tail will become mid - 1 = 4 and we finish search #if 5 is the answer, head = mid + 1 = 6 \u003e tail = 5, we also finish search # thus we should return tail as the result return tail Takeaways In my opinion, *Binary Search* is a possible solution when the questions contain the following information: 1. The question asks us to find an result and this results are comparable with each other so we could shrink the search space 2. The search space must be sorted 3. We also need pay attention to the final result (tail or mid) In this case, as long as we can transform the question into the case above, we could use *Binary Search* to solve it. ","wordCount":"2233","inLanguage":"en","image":"https://ydeng11.github.io/ihelio/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-10-08T16:28:21-04:00","dateModified":"2023-10-08T16:28:21-04:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-binary-search/"},"publisher":{"@type":"Organization","name":"iHelio","logo":{"@type":"ImageObject","url":"https://ydeng11.github.io/ihelio/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ydeng11.github.io/ihelio/ accesskey=h title="Home (Alt + H)"><img src=https://ydeng11.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ydeng11.github.io/ihelio/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://ydeng11.github.io/ihelio/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://ydeng11.github.io/ihelio/search/ title=Search><span>Search</span></a></li><li><a href=https://ydeng11.github.io/ihelio/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ydeng11.github.io/ihelio/>Home</a>&nbsp;»&nbsp;<a href=https://ydeng11.github.io/ihelio/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Coding Pattern: Binary Search</h1><div class=post-meta><span title='2023-10-08 16:28:21 -0400 EDT'>October 8, 2023</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2233 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/ydeng11/ihelio/tree/main/content/posts/2023/Coding%20Pattern:%20Binary%20Search.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h1><p>In one word, binary search is to search for a target in a sorted array. The idea is to shrink the search space to empty.</p><p>It must be sorted because we can be sure how to shrink the search space and we normally reduce the search space by half so the time complexity is <code>O(logN)</code> where <code>N</code> is the size of entire search space.</p><p>One common problem to understand <em>Binary Search</em> is how to identify the boundary of the search space.</p><p>The below is the pattern I am using to solve the most <em>Binary Search</em> questions.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=k>def</span> <span class=nf>search</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>nums</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>],</span> <span class=n>target</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>		<span class=c1># The boundary is inclusive which determines the while condition</span>
</span></span><span class=line><span class=cl>		<span class=n>head</span><span class=p>,</span> <span class=n>tail</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=c1># since the boundary is inclusive on the two ends of the nums array</span>
</span></span><span class=line><span class=cl>		<span class=c1># we should search even when head == tail and we should just check </span>
</span></span><span class=line><span class=cl>		<span class=c1># that particular value</span>
</span></span><span class=line><span class=cl>		<span class=k>while</span> <span class=n>head</span> <span class=o>&lt;=</span> <span class=n>tail</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=c1># we use floor division to make sure mid is an integer otherwise</span>
</span></span><span class=line><span class=cl>			<span class=c1># it cannot be used to index</span>
</span></span><span class=line><span class=cl>			<span class=c1># and using floor division will always result in a smaller value</span>
</span></span><span class=line><span class=cl>			<span class=c1># towards head so we don&#39;t want to stop search when head &lt; tail </span>
</span></span><span class=line><span class=cl>			<span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>head</span> <span class=o>+</span> <span class=n>tail</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>			<span class=c1># this is the part I love about this approach</span>
</span></span><span class=line><span class=cl>			<span class=c1># we can return the result right away if it is equal to the target as</span>
</span></span><span class=line><span class=cl>			<span class=c1># 1: we don&#39;t have to go through all search space</span>
</span></span><span class=line><span class=cl>			<span class=c1># 2: we can safely eliminate mid point in the next search</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=n>nums</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=n>mid</span>
</span></span><span class=line><span class=cl>			<span class=c1># if target is larger than nums[mid], it indicates the result sits</span>
</span></span><span class=line><span class=cl>			<span class=c1># on the left of mid, and otherwise the result sits on the right</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=n>nums</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=c1># since we are sure nums[mid] is not the result, we don&#39;t have</span>
</span></span><span class=line><span class=cl>				<span class=c1># to check nums[mid] again and we could move head to mid + 1</span>
</span></span><span class=line><span class=cl>				<span class=c1># otherwise, we move tail to mid - 1</span>
</span></span><span class=line><span class=cl>				<span class=n>head</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>			<span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>				<span class=n>tail</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>		<span class=c1># we are sure no results are found since all space are searched</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></div><h1 id=example-questions>Example Questions<a hidden class=anchor aria-hidden=true href=#example-questions>#</a></h1><p><a href=https://leetcode.com/problems/sqrtx/>69. Sqrt(x)</a></p><p>Given a non-negative integer <code>x</code>, return <em>the square root of</em> <code>x</code> <em>rounded down to the nearest integer</em>. The returned integer should be <strong>non-negative</strong> as well.</p><p>You <strong>must not use</strong> any built-in exponent function or operator.</p><ul><li>For example, do not use <code>pow(x, 0.5)</code> in c++ or <code>x ** 0.5</code> in python.</li></ul><p><strong>Example 1:</strong></p><p><strong>Input:</strong> x = 4
<strong>Output:</strong> 2
<strong>Explanation:</strong> The square root of 4 is 2, so we return 2.</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> x = 8
<strong>Output:</strong> 2
<strong>Explanation:</strong> The square root of 8 is 2.82842&mldr;, and since we round it down to the nearest integer, 2 is returned.</p><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= x &lt;= 231 - 1</code></li></ul><p>Solution:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=c1># we are using binary search because the search space is sorted and must be</span>
</span></span><span class=line><span class=cl>	<span class=c1># from [1, x]</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>mySqrt</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>:</span> <span class=k>return</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>        <span class=c1># The search space is [0, x//2] since it is to find the square root</span>
</span></span><span class=line><span class=cl>        <span class=n>head</span><span class=p>,</span> <span class=n>tail</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>x</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>head</span> <span class=o>&lt;=</span> <span class=n>tail</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>head</span> <span class=o>+</span> <span class=n>tail</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>            <span class=n>temp</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>*</span> <span class=n>mid</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>temp</span> <span class=o>==</span> <span class=n>x</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>mid</span>
</span></span><span class=line><span class=cl>            <span class=k>elif</span> <span class=n>temp</span> <span class=o>&lt;</span> <span class=n>x</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>head</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>tail</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>mid</span> <span class=o>*</span> <span class=n>mid</span> <span class=o>&gt;</span> <span class=n>x</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>mid</span>
</span></span></code></pre></div><p><a href=https://leetcode.com/problems/search-in-rotated-sorted-array/>33. Search in Rotated Sorted Array</a></p><p>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</p><p>Prior to being passed to your function, <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.</p><p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of</em> <code>target</code> <em>if it is in</em> <code>nums</code><em>, or</em> <code>-1</code> <em>if it is not in</em> <code>nums</code>.</p><p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 0
<strong>Output:</strong> 4</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 3
<strong>Output:</strong> -1</p><p><strong>Example 3:</strong></p><p><strong>Input:</strong> nums = [1], target = 0
<strong>Output:</strong> -1</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li>All values of <code>nums</code> are <strong>unique</strong>.</li><li><code>nums</code> is an ascending array that is possibly rotated.</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><p>Solution</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>search</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>nums</span><span class=p>:</span> <span class=nb>list</span><span class=p>[</span><span class=nb>int</span><span class=p>],</span> <span class=n>target</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>head</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=n>tail</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>head</span> <span class=o>&lt;=</span> <span class=n>tail</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>head</span> <span class=o>+</span> <span class=n>tail</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>nums</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>mid</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>nums</span><span class=p>[</span><span class=n>head</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>nums</span><span class=p>[</span><span class=n>mid</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>nums</span><span class=p>[</span><span class=n>head</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>target</span> <span class=o>&lt;=</span> <span class=n>nums</span><span class=p>[</span><span class=n>mid</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=n>tail</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>head</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>nums</span><span class=p>[</span><span class=n>mid</span><span class=p>]</span> <span class=o>&lt;=</span> <span class=n>target</span> <span class=o>&lt;=</span> <span class=n>nums</span><span class=p>[</span><span class=n>tail</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=n>head</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>tail</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span>
</span></span></code></pre></div><p><a href=https://leetcode.com/problems/median-of-two-sorted-arrays/>4. Median of Two Sorted Arrays</a></p><p>Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return <strong>the median</strong> of the two sorted arrays.</p><p>The overall run time complexity should be <code>O(log (m+n))</code>.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> nums1 = [1,3], nums2 = [2]
<strong>Output:</strong> 2.00000
<strong>Explanation:</strong> merged array = [1,2,3] and median is 2.</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> nums1 = [1,2], nums2 = [3,4]
<strong>Output:</strong> 2.50000
<strong>Explanation:</strong> merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.</p><p><strong>Constraints:</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li></ul><p>Solution:</p><p>This question has the following information:</p><ol><li>two <strong>sorted</strong> arrays</li><li>find the median of the two sorted arrays which indicate the non-descending order</li><li>time complexity is <code>O(log(m+n))</code> which is a big sign of <em>Binary Search</em></li></ol><p>The idea is to find the slice, say <code>mid1</code> and <code>mid2</code>, in two arrays and <code>nums1[mid1] &lt; nums2[mid2]</code> and <code>nums2[mid2] &lt; nums1[mid1]</code> so we know the elements on the left of <code>mid1</code> and <code>mid2</code> are smaller than the elements on the other side. Then we could get the median based on the size of the total elements.</p><p>And one key in this question is to make sure all the elements on the left add up should be equal to the half size of entire elements, then we can ensure the <code>mid1</code> and <code>mid2</code> represent the position of median values.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>findMedianSortedArrays</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>nums1</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>],</span> <span class=n>nums2</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=nb>float</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums1</span><span class=p>)</span> <span class=o>&gt;</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>findMedianSortedArrays</span><span class=p>(</span><span class=n>nums2</span><span class=p>,</span> <span class=n>nums1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>m</span><span class=p>,</span> <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums1</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># the search space is the length of the array unlike the index in above questions, this is important since the array is 0-indexed.</span>
</span></span><span class=line><span class=cl>        <span class=n>head</span><span class=p>,</span> <span class=n>tail</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>m</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>head</span> <span class=o>&lt;=</span> <span class=n>tail</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	        <span class=c1># this the length we attempt to grap from nums1</span>
</span></span><span class=line><span class=cl>            <span class=n>mid1</span> <span class=o>=</span> <span class=p>(</span><span class=n>head</span> <span class=o>+</span> <span class=n>tail</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>			<span class=c1># this is the length we attempt to grap from nums2, it is (m + n + 1)//2 - mid1 so mid2 will not be negative</span>
</span></span><span class=line><span class=cl>			<span class=c1># when mid1 increases and equal to m, (m + n)//2 - m could be negative when n &lt; m and (m + n) is odd, thus (m + n + 1) ensure mid2 won&#39;t be negative</span>
</span></span><span class=line><span class=cl>            <span class=n>mid2</span> <span class=o>=</span> <span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span> <span class=o>-</span> <span class=n>mid1</span>
</span></span><span class=line><span class=cl>			<span class=c1># if the length is 0 for either nums1 or nums2, the value on the left should be infinite negative since there is no value</span>
</span></span><span class=line><span class=cl>            <span class=n>maxLeft1</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s2>&#34;-inf&#34;</span><span class=p>)</span> <span class=k>if</span> <span class=n>mid1</span> <span class=o>==</span> <span class=mi>0</span> <span class=k>else</span> <span class=n>nums1</span><span class=p>[</span><span class=n>mid1</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>maxLeft2</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s2>&#34;-inf&#34;</span><span class=p>)</span> <span class=k>if</span> <span class=n>mid2</span> <span class=o>==</span> <span class=mi>0</span> <span class=k>else</span> <span class=n>nums2</span><span class=p>[</span><span class=n>mid2</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>			<span class=c1># likewise, if entire elements are grapped, the element on the right is infinite positive</span>
</span></span><span class=line><span class=cl>            <span class=n>minRight1</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s2>&#34;inf&#34;</span><span class=p>)</span> <span class=k>if</span> <span class=n>mid1</span> <span class=o>==</span> <span class=n>m</span> <span class=k>else</span> <span class=n>nums1</span><span class=p>[</span><span class=n>mid1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>minRight2</span> <span class=o>=</span> <span class=nb>float</span><span class=p>(</span><span class=s2>&#34;inf&#34;</span><span class=p>)</span> <span class=k>if</span> <span class=n>mid2</span> <span class=o>==</span> <span class=n>n</span> <span class=k>else</span> <span class=n>nums2</span><span class=p>[</span><span class=n>mid2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>			<span class=c1># since we get mid2 from mid1 and the total length, the mid1 and mid2 should always slice the entire elements into half and we only need check if the elements to the left of mid1 and mid2 are less than those on the other side.</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>maxLeft1</span> <span class=o>&lt;=</span> <span class=n>minRight2</span> <span class=ow>and</span> <span class=n>maxLeft2</span> <span class=o>&lt;=</span> <span class=n>minRight1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	            <span class=c1># if so, we calculate the median given the total size</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>m</span> <span class=o>+</span> <span class=n>n</span><span class=p>)</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	                <span class=c1># if it is even, we need the value on the left and right of mid since it requires two value</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=p>(</span><span class=nb>min</span><span class=p>(</span><span class=n>minRight1</span><span class=p>,</span> <span class=n>minRight2</span><span class=p>)</span> <span class=o>+</span> <span class=nb>max</span><span class=p>(</span><span class=n>maxLeft1</span><span class=p>,</span> <span class=n>maxLeft2</span><span class=p>))</span> <span class=o>/</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	                <span class=c1># otherwise, we only need the max of maxLeft1 and maxLeft2 </span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=nb>max</span><span class=p>(</span><span class=n>maxLeft1</span><span class=p>,</span> <span class=n>maxLeft2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	            <span class=c1># if the ending condition doesn&#39;t meet, we should adjust the search space to contain less elements from nums1 since the left value of mid1, maxLeft1, is larger than the right value of mid2, minRight2</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>maxLeft1</span> <span class=o>&gt;</span> <span class=n>minRight2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>tail</span> <span class=o>=</span> <span class=n>mid1</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>head</span> <span class=o>=</span> <span class=n>mid1</span> <span class=o>+</span> <span class=mi>1</span>
</span></span></code></pre></div><p><a href=https://leetcode.com/problems/cutting-ribbons/>1891. Cutting Ribbons</a></p><p>You are given an integer array <code>ribbons</code>, where <code>ribbons[i]</code> represents the length of the <code>ith</code> ribbon, and an integer <code>k</code>. You may cut any of the ribbons into any number of segments of <strong>positive integer</strong> lengths, or perform no cuts at all.</p><ul><li>For example, if you have a ribbon of length <code>4</code>, you can:<ul><li>Keep the ribbon of length <code>4</code>,</li><li>Cut it into one ribbon of length <code>3</code> and one ribbon of length <code>1</code>,</li><li>Cut it into two ribbons of length <code>2</code>,</li><li>Cut it into one ribbon of length <code>2</code> and two ribbons of length <code>1</code>, or</li><li>Cut it into four ribbons of length <code>1</code>.</li></ul></li></ul><p>Your goal is to obtain <code>k</code> ribbons of all the <strong>same positive integer length</strong>. You are allowed to throw away any excess ribbon as a result of cutting.</p><p>Return <em>the <strong>maximum</strong> possible positive integer length that you can obtain</em> <code>k</code> <em>ribbons of</em>_, or_ <code>0</code> <em>if you cannot obtain</em> <code>k</code> <em>ribbons of the same length</em>.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> ribbons = [9,7,5], k = 3
<strong>Output:</strong> 5
<strong>Explanation:</strong></p><ul><li>Cut the first ribbon to two ribbons, one of length 5 and one of length 4.</li><li>Cut the second ribbon to two ribbons, one of length 5 and one of length 2.</li><li>Keep the third ribbon as it is.
Now you have 3 ribbons of length 5.</li></ul><p><strong>Example 2:</strong></p><p><strong>Input:</strong> ribbons = [7,5,9], k = 4
<strong>Output:</strong> 4
<strong>Explanation:</strong></p><ul><li>Cut the first ribbon to two ribbons, one of length 4 and one of length 3.</li><li>Cut the second ribbon to two ribbons, one of length 4 and one of length 1.</li><li>Cut the third ribbon to three ribbons, two of length 4 and one of length 1.
Now you have 4 ribbons of length 4.</li></ul><p><strong>Example 3:</strong></p><p><strong>Input:</strong> ribbons = [5,7,9], k = 22
<strong>Output:</strong> 0
<strong>Explanation:</strong> You cannot obtain k ribbons of the same positive integer length.</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= ribbons.length &lt;= 105</code></li><li><code>1 &lt;= ribbons[i] &lt;= 105</code></li><li><code>1 &lt;= k &lt;= 109</code></li></ul><p>Solution:</p><p>This question asks if we could find a maximum possible length to cut the ribbons into <code>k</code> ribbons of the same size.</p><p>Therefore, we know it is a search question between the minimal length, 1, and the maximal length, the longest ribbon given.</p><p>And we want to have the maximum possible length of each cut. Suppose we have length <code>A</code> which yields more than <code>k</code> ribbons, we should try a larger value and otherwise a lesser value.</p><p><strong>The only difference with above questions is we have to go through the entire search space.</strong> And we are trying to find the maximal value, in our pattern, we should return $tail$ (the right end of search space) in the end.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>maxLength</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>ribbons</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>],</span> <span class=n>k</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	    <span class=c1># set the two end of search space</span>
</span></span><span class=line><span class=cl>        <span class=n>head</span><span class=p>,</span> <span class=n>tail</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=nb>max</span><span class=p>(</span><span class=n>ribbons</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=c1># check how many ribbons can be made</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=nf>helper</span><span class=p>(</span><span class=n>cut</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>ribbon</span> <span class=ow>in</span> <span class=n>ribbons</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>count</span> <span class=o>+=</span> <span class=n>ribbon</span> <span class=o>//</span> <span class=n>cut</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>count</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=n>head</span> <span class=o>&lt;=</span> <span class=n>tail</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>mid</span> <span class=o>=</span> <span class=p>(</span><span class=n>head</span> <span class=o>+</span> <span class=n>tail</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>            <span class=c1># if we get more than k rippons, we could try a larger value</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>helper</span><span class=p>(</span><span class=n>mid</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=n>k</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>head</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>tail</span> <span class=o>=</span> <span class=n>mid</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>        <span class=c1># here we return tail instead of mid</span>
</span></span><span class=line><span class=cl>        <span class=c1># In one word, the search space will be between two values at the end </span>
</span></span><span class=line><span class=cl>        <span class=c1># suppose head = 4 and tail = 5, so mid = 4 due to floor division, then we have two scenarios 4 is the answer and 4 is not the answer. But no matter what, we will make head = mid + 1 = 5 (since 4 will def generate k or more than k rippons, otherwise the head won&#39;t be 4 at the last round). </span>
</span></span><span class=line><span class=cl>        <span class=c1># When head = 5, the mid = 5</span>
</span></span><span class=line><span class=cl>	        <span class=c1>#if 5 is not the answer, tail will become mid - 1 = 4 and we finish search</span>
</span></span><span class=line><span class=cl>	        <span class=c1>#if 5 is the answer, head = mid + 1 = 6 &gt; tail = 5, we also finish search</span>
</span></span><span class=line><span class=cl>	    <span class=c1># thus we should return tail as the result   </span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>tail</span>
</span></span></code></pre></div><h3 id=takeaways>Takeaways<a hidden class=anchor aria-hidden=true href=#takeaways>#</a></h3><pre tabindex=0><code class=language-ad-hint data-lang=ad-hint>In my opinion, *Binary Search* is a possible solution when the questions contain the following information:
1. The question asks us to find an result and this results are comparable with each other so we could shrink the search space
2. The search space must be sorted
3. We also need pay attention to the final result (tail or mid)

In this case, as long as we can transform the question into the case above, we could use *Binary Search* to solve it.
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://ydeng11.github.io/ihelio/tags/algorithm/>Algorithm</a></li><li><a href=https://ydeng11.github.io/ihelio/tags/leetcode/>LeetCode</a></li></ul><nav class=paginav><a class=prev href=https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-divide--conquer/><span class=title>« Prev</span><br><span>Coding Pattern: Divide & Conquer</span>
</a><a class=next href=https://ydeng11.github.io/ihelio/posts/2023/build-a-home-media-server/><span class=title>Next »</span><br><span>Build a home media server but automated</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Binary Search on x" href="https://x.com/intent/tweet/?text=Coding%20Pattern%3a%20Binary%20Search&amp;url=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-binary-search%2f&amp;hashtags=Algorithm%2cLeetCode"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Binary Search on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-binary-search%2f&amp;title=Coding%20Pattern%3a%20Binary%20Search&amp;summary=Coding%20Pattern%3a%20Binary%20Search&amp;source=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-binary-search%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Binary Search on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-binary-search%2f&title=Coding%20Pattern%3a%20Binary%20Search"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Binary Search on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-binary-search%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Binary Search on whatsapp" href="https://api.whatsapp.com/send?text=Coding%20Pattern%3a%20Binary%20Search%20-%20https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-binary-search%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Binary Search on telegram" href="https://telegram.me/share/url?text=Coding%20Pattern%3a%20Binary%20Search&amp;url=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-binary-search%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Binary Search on ycombinator" href="https://news.ycombinator.com/submitlink?t=Coding%20Pattern%3a%20Binary%20Search&u=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-binary-search%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//ihelio-today.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://ydeng11.github.io/ihelio/>iHelio</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>