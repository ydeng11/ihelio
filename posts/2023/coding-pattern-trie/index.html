<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Coding Pattern: Trie | iHelio</title>
<meta name=keywords content="Algorithm,LeetCode"><meta name=description content="Overview The union-find algorithm is a data structure and algorithm that maintains a collection of disjoint sets. A disjoint set is a set of elements that are not connected to each other. The union-find algorithm can be used to perform the following operations:
Find: Find the set that an element belongs to. Union: Merge two sets together. The union-find algorithm is often used to solve problems that involve graph connectivity. For example, the union-find algorithm can be used to determine whether two nodes in a graph are connected, or to find all of the connected components in a graph."><meta name=author content="Me"><link rel=canonical href=https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-trie/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/ihelio/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://ydeng11.github.io/ihelio/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://ydeng11.github.io/ihelio/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ydeng11.github.io/ihelio/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ydeng11.github.io/ihelio/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://ydeng11.github.io/ihelio/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-trie/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-R4SSGN5Y2Z"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-R4SSGN5Y2Z")}</script><meta property="og:url" content="https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-trie/"><meta property="og:site_name" content="iHelio"><meta property="og:title" content="Coding Pattern: Trie"><meta property="og:description" content="Overview The union-find algorithm is a data structure and algorithm that maintains a collection of disjoint sets. A disjoint set is a set of elements that are not connected to each other. The union-find algorithm can be used to perform the following operations:
Find: Find the set that an element belongs to. Union: Merge two sets together. The union-find algorithm is often used to solve problems that involve graph connectivity. For example, the union-find algorithm can be used to determine whether two nodes in a graph are connected, or to find all of the connected components in a graph."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-22T21:41:02-04:00"><meta property="article:modified_time" content="2023-10-22T21:41:02-04:00"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="LeetCode"><meta property="og:image" content="https://ydeng11.github.io/ihelio/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ydeng11.github.io/ihelio/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Coding Pattern: Trie"><meta name=twitter:description content="Overview The union-find algorithm is a data structure and algorithm that maintains a collection of disjoint sets. A disjoint set is a set of elements that are not connected to each other. The union-find algorithm can be used to perform the following operations:
Find: Find the set that an element belongs to. Union: Merge two sets together. The union-find algorithm is often used to solve problems that involve graph connectivity. For example, the union-find algorithm can be used to determine whether two nodes in a graph are connected, or to find all of the connected components in a graph."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ydeng11.github.io/ihelio/posts/"},{"@type":"ListItem","position":2,"name":"Coding Pattern: Trie","item":"https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-trie/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Coding Pattern: Trie","name":"Coding Pattern: Trie","description":"Overview The union-find algorithm is a data structure and algorithm that maintains a collection of disjoint sets. A disjoint set is a set of elements that are not connected to each other. The union-find algorithm can be used to perform the following operations:\nFind: Find the set that an element belongs to. Union: Merge two sets together. The union-find algorithm is often used to solve problems that involve graph connectivity. For example, the union-find algorithm can be used to determine whether two nodes in a graph are connected, or to find all of the connected components in a graph.","keywords":["Algorithm","LeetCode"],"articleBody":"Overview The union-find algorithm is a data structure and algorithm that maintains a collection of disjoint sets. A disjoint set is a set of elements that are not connected to each other. The union-find algorithm can be used to perform the following operations:\nFind: Find the set that an element belongs to. Union: Merge two sets together. The union-find algorithm is often used to solve problems that involve graph connectivity. For example, the union-find algorithm can be used to determine whether two nodes in a graph are connected, or to find all of the connected components in a graph.\nHere is an illustrative example of the union-find algorithm:\nImagine that we have a set of 5 elements: A, B, C, D, and E. We can use the union-find algorithm to maintain a collection of disjoint sets of these elements.\nInitially, all of the elements are in their own separate sets:\nSet 1: A Set 2: B Set 3: C Set 4: D Set 5: E Now, let’s say that we want to merge Set 1 and Set 2. We can use the union-find algorithm to do this by combining the two sets into a single set:\nSet 1: A, B Set 3: C Set 4: D Set 5: E We can also use the union-find algorithm to find the set that an element belongs to. For example, if we want to find the set that element B belongs to, we can use the union-find algorithm to determine that B is in Set 1.\nThe union-find algorithm is a powerful tool that can be used to solve a wide variety of problems. It is often used to solve problems that involve graph connectivity, such as finding the connected components in a graph or determining whether two nodes in a graph are connected.\nHere is a diagram that illustrates the union-find algorithm:\nSet 1 / \\ A B \\ / Set 2 In this diagram, Set 1 and Set 2 are merged together. The union-find algorithm maintains a tree structure for each set. The root of the tree is the representative of the set. In this diagram, A is the representative of Set 1 and B is the representative of Set 2.\nTo find the set that an element belongs to, the union-find algorithm follows the pointers from the element to the root of the tree. For example, to find the set that B belongs to, we would follow the pointer from B to A. Since A is the root of the tree, we know that B is in Set 1.\nTo merge two sets together, the union-find algorithm makes the root of one tree the child of the root of the other tree. For example, to merge Set 1 and Set 2, we would make B the child of A. This would create a single tree that represents both Set 1 and Set 2.\nThe union-find algorithm is a very efficient algorithm for maintaining a collection of disjoint sets. It is often used in graph algorithms, such as Kruskal’s algorithm and Prim’s algorithm.\nExample of Implementation class UnionFind: def __init__(self): self.parents = {} self.size = {} def insert(self, x): if x not in self.parents: self.parents[x] = x self.size[x] = 1 # recursively find the uppermost parent node (path compression) def find(self, node): if self.parents[node] != node: self.parents[node] = self.find(self.parents[node]) return self.parents[node] # merge two objects into one set def union(self, x, y): # insert x and y into the parents and size dict self.insert(x) self.insert(y) # find the parent of x and y (union by rank) px, py = self.find(x), self.find(y) # they are already in the same set if their parents are the same if px == py: return # always make px the less parent if self.size[px] \u003e self.size[py]: px, py = py, px # so the parent of px is py since px is less self.parents[px] = py # increase the size of py self.size[py] += self.size[px] Space Complexity: The space complexity for the Union-Find data structure is $O(n)$, where n is the number of elements. This is because, typically, two arrays (or vectors) of size $n$ are maintained: one for parent pointers and another for ranks/sizes.\nTime Complexity: Without optimizations, the operations can be quite slow. However, with the Union by Rank and Path Compression optimizations, the operations become much faster.\nUnion Operation (with Union by Rank): This operation ensures that when two sets are combined, the smaller set (in terms of rank) is attached to the root of the larger set. This keeps the tree relatively flat. This operation is generally $O(1)$ but can be considered $O(logn)$ in the worst case because in the worst case the height of the tree can grow up to $logn$. Find Operation (with Path Compression): When performing a find operation to determine the root of a particular element, the algorithm traverses up the tree and, in the process, flattens the tree by making every node point directly to the root. This makes future find operations faster. The amortized time complexity of the find operation with path compression (and union by rank) is near $O(1)$. However, when considering sequences of operations, the inverse Ackermann function, $α(n)$, often comes into play, making the operations effectively constant time for all practical purposes. Union (combined with Find): Since the union operation often involves two find operations (to get the roots of the two sets being unioned), its time complexity is also governed by the find operation. Thus, its amortized time complexity is also effectively constant for practical purposes, but academically it’s often cited as $O(α(n))$. In summary, with the Union by Rank and Path Compression optimizations, the Union-Find operations become nearly constant time, $O(α(n))$, where $α(n)$ is the inverse Ackermann function, which grows extremely slowly. For most practical purposes, it’s considered constant time.\nExample Questions 721. Accounts Merge Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.\nNow, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.\nAfter merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.\nExample 1:\nInput: accounts = [[“John”,“johnsmith@mail.com”,“john_newyork@mail.com”],[“John”,“johnsmith@mail.com”,“john00@mail.com”],[“Mary”,“mary@mail.com”],[“John”,“johnnybravo@mail.com”]] Output: [[“John”,“john00@mail.com”,“john_newyork@mail.com”,“johnsmith@mail.com”],[“Mary”,“mary@mail.com”],[“John”,“johnnybravo@mail.com”]] Explanation: The first and second John’s are the same person as they have the common email “johnsmith@mail.com”. The third John and Mary are different people as none of their email addresses are used by other accounts. We could return these lists in any order, for example the answer [[‘Mary’, ‘mary@mail.com’], [‘John’, ‘johnnybravo@mail.com’], [‘John’, ‘john00@mail.com’, ‘john_newyork@mail.com’, ‘johnsmith@mail.com’]] would still be accepted.\nExample 2:\nInput: accounts = [[“Gabe”,“Gabe0@m.co”,“Gabe3@m.co”,“Gabe1@m.co”],[“Kevin”,“Kevin3@m.co”,“Kevin5@m.co”,“Kevin0@m.co”],[“Ethan”,“Ethan5@m.co”,“Ethan4@m.co”,“Ethan0@m.co”],[“Hanzo”,“Hanzo3@m.co”,“Hanzo1@m.co”,“Hanzo0@m.co”],[“Fern”,“Fern5@m.co”,“Fern1@m.co”,“Fern0@m.co”]] Output: [[“Ethan”,“Ethan0@m.co”,“Ethan4@m.co”,“Ethan5@m.co”],[“Gabe”,“Gabe0@m.co”,“Gabe1@m.co”,“Gabe3@m.co”],[“Hanzo”,“Hanzo0@m.co”,“Hanzo1@m.co”,“Hanzo3@m.co”],[“Kevin”,“Kevin0@m.co”,“Kevin3@m.co”,“Kevin5@m.co”],[“Fern”,“Fern0@m.co”,“Fern1@m.co”,“Fern5@m.co”]]\nConstraints:\n1 \u003c= accounts.length \u003c= 1000 2 \u003c= accounts[i].length \u003c= 10 1 \u003c= accounts[i][j].length \u003c= 30 accounts[i][0] consists of English letters. accounts[i][j] (for j \u003e 0) is a valid email. Solution class UnionFind: def __init__(self): self.parents = {} self.size = {} def insert(self, x): if x not in self.parents: self.parents[x] = x self.size[x] = 1 def find(self, node): if self.parents[node] != node: self.parents[node] = self.find(self.parents[node]) return self.parents[node] def union(self, x, y): self.insert(x) self.insert(y) px, py = self.find(x), self.find(y) if px == py: return if self.size[px] \u003e self.size[py]: px, py = py, px self.parents[px] = py self.size[py] += self.size[px] class Solution: def accountsMerge(self, accounts: List[List[str]]) -\u003e List[List[str]]: uf = UnionFind() name_map = {} for account in accounts: name, emails = account[0], account[1:] for email in emails: name_map[email] = name # merge all the emails with the first email uf.union(emails[0], email) out = defaultdict(list) for key in uf.parents.keys(): # group all emails based on their parent in union-find out[uf.find(key)].append(key) res = [] for key, val in out.items(): res.append([name_map[key]] + sorted(val)) return res Time Complexity: $O(n)$ where $n$ is the number of emails, it is $n$ because of union-by-rank Space Complexity: $O(n)$\n","wordCount":"1381","inLanguage":"en","image":"https://ydeng11.github.io/ihelio/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-10-22T21:41:02-04:00","dateModified":"2023-10-22T21:41:02-04:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-trie/"},"publisher":{"@type":"Organization","name":"iHelio","logo":{"@type":"ImageObject","url":"https://ydeng11.github.io/ihelio/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ydeng11.github.io/ihelio/ accesskey=h title="Home (Alt + H)"><img src=https://ydeng11.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ydeng11.github.io/ihelio/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://ydeng11.github.io/ihelio/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://ydeng11.github.io/ihelio/search/ title=Search><span>Search</span></a></li><li><a href=https://ydeng11.github.io/ihelio/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ydeng11.github.io/ihelio/>Home</a>&nbsp;»&nbsp;<a href=https://ydeng11.github.io/ihelio/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Coding Pattern: Trie</h1><div class=post-meta><span title='2023-10-22 21:41:02 -0400 EDT'>October 22, 2023</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;1381 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/ydeng11/ihelio/tree/main/content/posts/2023/Coding%20Pattern:%20Trie.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h1><p>The union-find algorithm is a data structure and algorithm that maintains a collection of disjoint sets. A disjoint set is a set of elements that are not connected to each other. The union-find algorithm can be used to perform the following operations:</p><ul><li><strong>Find:</strong> Find the set that an element belongs to.</li><li><strong>Union:</strong> Merge two sets together.</li></ul><p>The union-find algorithm is often used to solve problems that involve graph connectivity. For example, the union-find algorithm can be used to determine whether two nodes in a graph are connected, or to find all of the connected components in a graph.</p><p>Here is an illustrative example of the union-find algorithm:</p><p>Imagine that we have a set of 5 elements: A, B, C, D, and E. We can use the union-find algorithm to maintain a collection of disjoint sets of these elements.</p><p>Initially, all of the elements are in their own separate sets:</p><pre tabindex=0><code>Set 1: A
Set 2: B
Set 3: C
Set 4: D
Set 5: E
</code></pre><p>Now, let&rsquo;s say that we want to merge Set 1 and Set 2. We can use the union-find algorithm to do this by combining the two sets into a single set:</p><pre tabindex=0><code>Set 1: A, B
Set 3: C
Set 4: D
Set 5: E
</code></pre><p>We can also use the union-find algorithm to find the set that an element belongs to. For example, if we want to find the set that element B belongs to, we can use the union-find algorithm to determine that B is in Set 1.</p><p>The union-find algorithm is a powerful tool that can be used to solve a wide variety of problems. It is often used to solve problems that involve graph connectivity, such as finding the connected components in a graph or determining whether two nodes in a graph are connected.</p><p>Here is a diagram that illustrates the union-find algorithm:</p><pre tabindex=0><code>        Set 1
       /    \
      A      B
       \    /
        Set 2
</code></pre><p>In this diagram, Set 1 and Set 2 are merged together. The union-find algorithm maintains a tree structure for each set. The root of the tree is the representative of the set. In this diagram, A is the representative of Set 1 and B is the representative of Set 2.</p><p>To find the set that an element belongs to, the union-find algorithm follows the pointers from the element to the root of the tree. For example, to find the set that B belongs to, we would follow the pointer from B to A. Since A is the root of the tree, we know that B is in Set 1.</p><p>To merge two sets together, the union-find algorithm makes the root of one tree the child of the root of the other tree. For example, to merge Set 1 and Set 2, we would make B the child of A. This would create a single tree that represents both Set 1 and Set 2.</p><p>The union-find algorithm is a very efficient algorithm for maintaining a collection of disjoint sets. It is often used in graph algorithms, such as Kruskal&rsquo;s algorithm and Prim&rsquo;s algorithm.</p><h2 id=example-of-implementation>Example of Implementation<a hidden class=anchor aria-hidden=true href=#example-of-implementation>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>UnionFind</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>parents</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>size</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>insert</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>x</span> <span class=ow>not</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>parents</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>parents</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>=</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>size</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1># recursively find the uppermost parent node (path compression)</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>find</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>parents</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>!=</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>parents</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>parents</span><span class=p>[</span><span class=n>node</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>parents</span><span class=p>[</span><span class=n>node</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1># merge two objects into one set</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>union</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	    <span class=c1># insert x and y into the parents and size dict</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># find the parent of x and y (union by rank)</span>
</span></span><span class=line><span class=cl>        <span class=n>px</span><span class=p>,</span> <span class=n>py</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>x</span><span class=p>),</span> <span class=bp>self</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># they are already in the same set if their parents are the same</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>px</span> <span class=o>==</span> <span class=n>py</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        <span class=c1># always make px the less parent</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span><span class=p>[</span><span class=n>px</span><span class=p>]</span> <span class=o>&gt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span><span class=p>[</span><span class=n>py</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>px</span><span class=p>,</span> <span class=n>py</span> <span class=o>=</span> <span class=n>py</span><span class=p>,</span> <span class=n>px</span>
</span></span><span class=line><span class=cl>        <span class=c1># so the parent of px is py since px is less</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>parents</span><span class=p>[</span><span class=n>px</span><span class=p>]</span> <span class=o>=</span> <span class=n>py</span>
</span></span><span class=line><span class=cl>        <span class=c1># increase the size of py</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>size</span><span class=p>[</span><span class=n>py</span><span class=p>]</span> <span class=o>+=</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span><span class=p>[</span><span class=n>px</span><span class=p>]</span>
</span></span></code></pre></div><p><strong>Space Complexity</strong>:
The space complexity for the Union-Find data structure is $O(n)$, where n is the number of elements. This is because, typically, two arrays (or vectors) of size $n$ are maintained: one for parent pointers and another for ranks/sizes.</p><p><strong>Time Complexity</strong>:
Without optimizations, the operations can be quite slow. However, with the <strong>Union by Rank</strong> and <strong>Path Compression</strong> optimizations, the operations become much faster.</p><ul><li><strong>Union Operation (with Union by Rank)</strong>: This operation ensures that when two sets are combined, the smaller set (in terms of rank) is attached to the root of the larger set. This keeps the tree relatively flat. This operation is generally $O(1)$ but can be considered $O(logn)$ in the worst case because in the worst case the height of the tree can grow up to $logn$.</li><li><strong>Find Operation (with Path Compression)</strong>: When performing a <code>find</code> operation to determine the root of a particular element, the algorithm traverses up the tree and, in the process, flattens the tree by making every node point directly to the root. This makes future <code>find</code> operations faster. The amortized time complexity of the <code>find</code> operation with path compression (and union by rank) is near $O(1)$. However, when considering sequences of operations, the inverse Ackermann function, $α(n)$, often comes into play, making the operations effectively constant time for all practical purposes.</li><li><strong>Union (combined with Find)</strong>: Since the union operation often involves two <code>find</code> operations (to get the roots of the two sets being unioned), its time complexity is also governed by the <code>find</code> operation. Thus, its amortized time complexity is also effectively constant for practical purposes, but academically it&rsquo;s often cited as $O(α(n))$.</li></ul><p>In summary, with the Union by Rank and Path Compression optimizations, the Union-Find operations become nearly constant time, $O(α(n))$, where $α(n)$ is the inverse Ackermann function, which grows extremely slowly. For most practical purposes, <strong>it&rsquo;s considered constant time.</strong></p><h1 id=example-questions>Example Questions<a hidden class=anchor aria-hidden=true href=#example-questions>#</a></h1><h2 id=721-accounts-mergehttpsleetcodecomproblemsaccounts-merge><a href=https://leetcode.com/problems/accounts-merge/>721. Accounts Merge</a><a hidden class=anchor aria-hidden=true href=#721-accounts-mergehttpsleetcodecomproblemsaccounts-merge>#</a></h2><p>Given a list of <code>accounts</code> where each element <code>accounts[i]</code> is a list of strings, where the first element <code>accounts[i][0]</code> is a name, and the rest of the elements are <strong>emails</strong> representing emails of the account.</p><p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p><p>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails <strong>in sorted order</strong>. The accounts themselves can be returned in <strong>any order</strong>.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> accounts = [[&ldquo;John&rdquo;,&ldquo;johnsmith@mail.com&rdquo;,&ldquo;john_newyork@mail.com&rdquo;],[&ldquo;John&rdquo;,&ldquo;johnsmith@mail.com&rdquo;,&ldquo;john00@mail.com&rdquo;],[&ldquo;Mary&rdquo;,&ldquo;mary@mail.com&rdquo;],[&ldquo;John&rdquo;,&ldquo;johnnybravo@mail.com&rdquo;]]
<strong>Output:</strong> [[&ldquo;John&rdquo;,&ldquo;john00@mail.com&rdquo;,&ldquo;john_newyork@mail.com&rdquo;,&ldquo;johnsmith@mail.com&rdquo;],[&ldquo;Mary&rdquo;,&ldquo;mary@mail.com&rdquo;],[&ldquo;John&rdquo;,&ldquo;johnnybravo@mail.com&rdquo;]]
<strong>Explanation:</strong>
The first and second John&rsquo;s are the same person as they have the common email &ldquo;<a href=mailto:johnsmith@mail.com>johnsmith@mail.com</a>&rdquo;.
The third John and Mary are different people as none of their email addresses are used by other accounts.
We could return these lists in any order, for example the answer [[&lsquo;Mary&rsquo;, &lsquo;mary@mail.com&rsquo;], [&lsquo;John&rsquo;, &lsquo;johnnybravo@mail.com&rsquo;],
[&lsquo;John&rsquo;, &lsquo;john00@mail.com&rsquo;, &lsquo;john_newyork@mail.com&rsquo;, &lsquo;johnsmith@mail.com&rsquo;]] would still be accepted.</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> accounts = [[&ldquo;Gabe&rdquo;,&ldquo;Gabe0@m.co&rdquo;,&ldquo;Gabe3@m.co&rdquo;,&ldquo;Gabe1@m.co&rdquo;],[&ldquo;Kevin&rdquo;,&ldquo;Kevin3@m.co&rdquo;,&ldquo;Kevin5@m.co&rdquo;,&ldquo;Kevin0@m.co&rdquo;],[&ldquo;Ethan&rdquo;,&ldquo;Ethan5@m.co&rdquo;,&ldquo;Ethan4@m.co&rdquo;,&ldquo;Ethan0@m.co&rdquo;],[&ldquo;Hanzo&rdquo;,&ldquo;Hanzo3@m.co&rdquo;,&ldquo;Hanzo1@m.co&rdquo;,&ldquo;Hanzo0@m.co&rdquo;],[&ldquo;Fern&rdquo;,&ldquo;Fern5@m.co&rdquo;,&ldquo;Fern1@m.co&rdquo;,&ldquo;Fern0@m.co&rdquo;]]
<strong>Output:</strong> [[&ldquo;Ethan&rdquo;,&ldquo;Ethan0@m.co&rdquo;,&ldquo;Ethan4@m.co&rdquo;,&ldquo;Ethan5@m.co&rdquo;],[&ldquo;Gabe&rdquo;,&ldquo;Gabe0@m.co&rdquo;,&ldquo;Gabe1@m.co&rdquo;,&ldquo;Gabe3@m.co&rdquo;],[&ldquo;Hanzo&rdquo;,&ldquo;Hanzo0@m.co&rdquo;,&ldquo;Hanzo1@m.co&rdquo;,&ldquo;Hanzo3@m.co&rdquo;],[&ldquo;Kevin&rdquo;,&ldquo;Kevin0@m.co&rdquo;,&ldquo;Kevin3@m.co&rdquo;,&ldquo;Kevin5@m.co&rdquo;],[&ldquo;Fern&rdquo;,&ldquo;Fern0@m.co&rdquo;,&ldquo;Fern1@m.co&rdquo;,&ldquo;Fern5@m.co&rdquo;]]</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= accounts.length &lt;= 1000</code></li><li><code>2 &lt;= accounts[i].length &lt;= 10</code></li><li><code>1 &lt;= accounts[i][j].length &lt;= 30</code></li><li><code>accounts[i][0]</code> consists of English letters.</li><li><code>accounts[i][j] (for j > 0)</code> is a valid email.</li></ul><h2 id=solution>Solution<a hidden class=anchor aria-hidden=true href=#solution>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>UnionFind</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>parents</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>size</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>insert</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>x</span> <span class=ow>not</span> <span class=ow>in</span> <span class=bp>self</span><span class=o>.</span><span class=n>parents</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>parents</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>=</span> <span class=n>x</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>size</span><span class=p>[</span><span class=n>x</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>find</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>parents</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>!=</span> <span class=n>node</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=bp>self</span><span class=o>.</span><span class=n>parents</span><span class=p>[</span><span class=n>node</span><span class=p>]</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>parents</span><span class=p>[</span><span class=n>node</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>parents</span><span class=p>[</span><span class=n>node</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>union</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>px</span><span class=p>,</span> <span class=n>py</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>x</span><span class=p>),</span> <span class=bp>self</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>y</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>px</span> <span class=o>==</span> <span class=n>py</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span><span class=p>[</span><span class=n>px</span><span class=p>]</span> <span class=o>&gt;</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span><span class=p>[</span><span class=n>py</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>            <span class=n>px</span><span class=p>,</span> <span class=n>py</span> <span class=o>=</span> <span class=n>py</span><span class=p>,</span> <span class=n>px</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>parents</span><span class=p>[</span><span class=n>px</span><span class=p>]</span> <span class=o>=</span> <span class=n>py</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>size</span><span class=p>[</span><span class=n>py</span><span class=p>]</span> <span class=o>+=</span> <span class=bp>self</span><span class=o>.</span><span class=n>size</span><span class=p>[</span><span class=n>px</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>accountsMerge</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>accounts</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=n>List</span><span class=p>[</span><span class=nb>str</span><span class=p>]])</span> <span class=o>-&gt;</span> <span class=n>List</span><span class=p>[</span><span class=n>List</span><span class=p>[</span><span class=nb>str</span><span class=p>]]:</span>
</span></span><span class=line><span class=cl>        <span class=n>uf</span> <span class=o>=</span> <span class=n>UnionFind</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>name_map</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>account</span> <span class=ow>in</span> <span class=n>accounts</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>name</span><span class=p>,</span> <span class=n>emails</span> <span class=o>=</span> <span class=n>account</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>account</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>email</span> <span class=ow>in</span> <span class=n>emails</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>name_map</span><span class=p>[</span><span class=n>email</span><span class=p>]</span> <span class=o>=</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>                <span class=c1># merge all the emails with the first email</span>
</span></span><span class=line><span class=cl>                <span class=n>uf</span><span class=o>.</span><span class=n>union</span><span class=p>(</span><span class=n>emails</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>email</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        <span class=n>out</span> <span class=o>=</span> <span class=n>defaultdict</span><span class=p>(</span><span class=nb>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>key</span> <span class=ow>in</span> <span class=n>uf</span><span class=o>.</span><span class=n>parents</span><span class=o>.</span><span class=n>keys</span><span class=p>():</span>
</span></span><span class=line><span class=cl>		    <span class=c1># group all emails based on their parent in union-find</span>
</span></span><span class=line><span class=cl>            <span class=n>out</span><span class=p>[</span><span class=n>uf</span><span class=o>.</span><span class=n>find</span><span class=p>(</span><span class=n>key</span><span class=p>)]</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>        <span class=n>res</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>key</span><span class=p>,</span> <span class=n>val</span> <span class=ow>in</span> <span class=n>out</span><span class=o>.</span><span class=n>items</span><span class=p>():</span>
</span></span><span class=line><span class=cl>            <span class=n>res</span><span class=o>.</span><span class=n>append</span><span class=p>([</span><span class=n>name_map</span><span class=p>[</span><span class=n>key</span><span class=p>]]</span> <span class=o>+</span> <span class=nb>sorted</span><span class=p>(</span><span class=n>val</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>res</span>
</span></span></code></pre></div><p>Time Complexity: $O(n)$ where $n$ is the number of emails, it is $n$ because of union-by-rank
Space Complexity: $O(n)$</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ydeng11.github.io/ihelio/tags/algorithm/>Algorithm</a></li><li><a href=https://ydeng11.github.io/ihelio/tags/leetcode/>LeetCode</a></li></ul><nav class=paginav><a class=prev href=https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-recursion/><span class=title>« Prev</span><br><span>Coding Pattern: Recursion</span>
</a><a class=next href=https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-two-pointers/><span class=title>Next »</span><br><span>Coding Pattern: Two Pointers</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Trie on x" href="https://x.com/intent/tweet/?text=Coding%20Pattern%3a%20Trie&amp;url=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-trie%2f&amp;hashtags=Algorithm%2cLeetCode"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Trie on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-trie%2f&amp;title=Coding%20Pattern%3a%20Trie&amp;summary=Coding%20Pattern%3a%20Trie&amp;source=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-trie%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Trie on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-trie%2f&title=Coding%20Pattern%3a%20Trie"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Trie on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-trie%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Trie on whatsapp" href="https://api.whatsapp.com/send?text=Coding%20Pattern%3a%20Trie%20-%20https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-trie%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Trie on telegram" href="https://telegram.me/share/url?text=Coding%20Pattern%3a%20Trie&amp;url=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-trie%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Trie on ycombinator" href="https://news.ycombinator.com/submitlink?t=Coding%20Pattern%3a%20Trie&u=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-trie%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//ihelio-today.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://ydeng11.github.io/ihelio/>iHelio</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>