<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Coding Pattern: Divide & Conquer | iHelio</title>
<meta name=keywords content="Algorithm,LeetCode"><meta name=description content="Overview The Divide-n-Conquer strategy often employs recursion, as it relies on applying the same method to reduce the problem size by half and subsequently combining the outcomes for the ultimate solution.
I view Divide-n-Conquer in a light similar to MapReduce, particularly when the task involves transformation. MapReduce breaks down a large problem into more manageable, independent sub-problems. Since each of these sub-problems operates autonomously, we can address them sequentially and still integrate their solutions."><meta name=author content="Me"><link rel=canonical href=https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-divide--conquer/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/ihelio/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://ydeng11.github.io/ihelio/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://ydeng11.github.io/ihelio/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ydeng11.github.io/ihelio/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ydeng11.github.io/ihelio/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://ydeng11.github.io/ihelio/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-divide--conquer/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-R4SSGN5Y2Z"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-R4SSGN5Y2Z")}</script><meta property="og:url" content="https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-divide--conquer/"><meta property="og:site_name" content="iHelio"><meta property="og:title" content="Coding Pattern: Divide & Conquer"><meta property="og:description" content="Overview The Divide-n-Conquer strategy often employs recursion, as it relies on applying the same method to reduce the problem size by half and subsequently combining the outcomes for the ultimate solution.
I view Divide-n-Conquer in a light similar to MapReduce, particularly when the task involves transformation. MapReduce breaks down a large problem into more manageable, independent sub-problems. Since each of these sub-problems operates autonomously, we can address them sequentially and still integrate their solutions."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-08T22:46:03-04:00"><meta property="article:modified_time" content="2023-10-08T22:46:03-04:00"><meta property="article:tag" content="Algorithm"><meta property="article:tag" content="LeetCode"><meta property="og:image" content="https://ydeng11.github.io/ihelio/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ydeng11.github.io/ihelio/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Coding Pattern: Divide & Conquer"><meta name=twitter:description content="Overview The Divide-n-Conquer strategy often employs recursion, as it relies on applying the same method to reduce the problem size by half and subsequently combining the outcomes for the ultimate solution.
I view Divide-n-Conquer in a light similar to MapReduce, particularly when the task involves transformation. MapReduce breaks down a large problem into more manageable, independent sub-problems. Since each of these sub-problems operates autonomously, we can address them sequentially and still integrate their solutions."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ydeng11.github.io/ihelio/posts/"},{"@type":"ListItem","position":2,"name":"Coding Pattern: Divide \u0026 Conquer","item":"https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-divide--conquer/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Coding Pattern: Divide \u0026 Conquer","name":"Coding Pattern: Divide \u0026 Conquer","description":"Overview The Divide-n-Conquer strategy often employs recursion, as it relies on applying the same method to reduce the problem size by half and subsequently combining the outcomes for the ultimate solution.\nI view Divide-n-Conquer in a light similar to MapReduce, particularly when the task involves transformation. MapReduce breaks down a large problem into more manageable, independent sub-problems. Since each of these sub-problems operates autonomously, we can address them sequentially and still integrate their solutions.","keywords":["Algorithm","LeetCode"],"articleBody":"Overview The Divide-n-Conquer strategy often employs recursion, as it relies on applying the same method to reduce the problem size by half and subsequently combining the outcomes for the ultimate solution.\nI view Divide-n-Conquer in a light similar to MapReduce, particularly when the task involves transformation. MapReduce breaks down a large problem into more manageable, independent sub-problems. Since each of these sub-problems operates autonomously, we can address them sequentially and still integrate their solutions. Key to this approach is ensuring the main problem can be independently segmented and the derived solutions can be seamlessly merged.\nThe typical blueprint for Divide-n-Conquer involves a recursive function. This function produces a result when the size becomes null and provides mechanisms to split the problem and amalgamate the solutions. Consequently, time complexity predominantly depends on this recursive function.\nExample Questions 108. Convert Sorted Array to Binary Search Tree Given an integer array `nums` where the elements are sorted in **ascending order**, convert _it to a_ **_height-balanced_** _binary search tree_. **Example 1:** ![](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg) **Input:** nums = [-10,-3,0,5,9] **Output:** [0,-3,9,-10,null,5] **Explanation:** [0,-10,5,null,-3,null,9] is also accepted: ![](https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg) **Example 2:** ![](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg) **Input:** nums = [1,3] **Output:** [3,1] **Explanation:** [1,null,3] and [3,1] are both height-balanced BSTs. Solution: The question asks to transform the sorted array into a height-balanced BST so:\nthe number of nodes on the left and right should be very close -\u003e implies how to divide the question the BST is resulted from the sorted array -\u003e indicates transformation If we split the array into separate arrays, each array is still sorted and can be transformed into a height-balanced BST, thus we can make a BST using these small BST # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def sortedArrayToBST(self, nums: List[int]) -\u003e Optional[TreeNode]: # We need an recursion to convert the divided arrays into BST def helper(nums): # if the array is empty, we should create a null node if len(nums) == 0: return None # if there is only one value in the array, this tree has only one node if len(nums) == 1: return TreeNode(nums[0]) # we are building a height-balanced BST, thus we should divide the nums array into half each time mid = len(nums) // 2 # the value at the mid is the root root = TreeNode(nums[mid]) # the left branch is the BST resulted from the left half array root.left = helper(nums[:mid]) # the right branch is the BST resulted from the right half array root.right = helper(nums[mid+1:]) return root return helper(nums) Time Complexity: O(N) even it is recursion, we are visiting each element exactly once Space Complexity: O(logN) it is the height of the BST tree we are creating\n215. Kth Largest Element in an Array Given an integer array `nums` and an integer `k`, return _the_ `kth` _largest element in the array_. Note that it is the `kth` largest element in the sorted order, not the `kth` distinct element. Can you solve it without sorting? **Example 1:** **Input:** nums = [3,2,1,5,6,4], k = 2 **Output:** 5 **Example 2:** **Input:** nums = [3,2,3,1,2,4,5,5,6], k = 4 **Output:** 4 **Constraints:** - `1 \u003c= k \u003c= nums.length \u003c= 105` - `-104 \u003c= nums[i] \u003c= 104` Solution This solution is to use quick select to find the Kth largest value from a non-sorted array. Quick select is essentially divide-n-conquer as:\nwe divide the array using a random pivot check which subarray could contain the kth largest value continue the search until we get the result we need a recursion function to work on each array import heapq class Solution: def findKthLargest(self, nums: List[int], k: int) -\u003e int: def quick_select(nums, k): # random select a value from the array pivot = random.choice(nums) # create the subarray contains the larger, smaller and equaivalent values more, less, equal = [], [], [] for num in nums: if num \u003e pivot: more.append(num) elif num \u003c pivot: less.append(num) else: equal.append(num) # If there are more than k elements larger than the pivot in array more, we can search kth largest value from more and it is same kth largest value as the original array if len(more) \u003e= k: return quick_select(more, k) # If the number of larger and equaivalent values are less than k, the kth largest value should be in less array, but we cannot find kth largest value from less since it will result in a much smaller value. # we need identify the new kth target in the less array if len(more) + len(equal) \u003c k: return quick_select(less, k - len(more) - len(equal)) # otherwise, the pivot should be the kth largest value return pivot return quick_select(nums, k) 23. Merge k Sorted Lists You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order. _Merge all the linked-lists into one sorted linked-list and return it._ **Example 1:** **Input:** lists = [[1,4,5],[1,3,4],[2,6]] **Output:** [1,1,2,3,4,4,5,6] **Explanation:** The linked-lists are: [ 1-\u003e4-\u003e5, 1-\u003e3-\u003e4, 2-\u003e6 ] merging them into one sorted list: 1-\u003e1-\u003e2-\u003e3-\u003e4-\u003e4-\u003e5-\u003e6 **Example 2:** **Input:** lists = [] **Output:** [] **Example 3:** **Input:** lists = [[]] **Output:** [] **Constraints:** - `k == lists.length` - `0 \u003c= k \u003c= 104` - `0 \u003c= lists[i].length \u003c= 500` - `-104 \u003c= lists[i][j] \u003c= 104` - `lists[i]` is sorted in **ascending order**. - The sum of `lists[i].length` will not exceed `104`. Solution This is an advanced question based off 21. Merge Two Sorted Lists.\nAnd this question has the following characteristics leading to divide-n-conquer:\nmerge k sorted list is the same as merge 2 sorted lists, since we want one single sorted list in the end it is similar to MapReduce, aggregate multiple lists into one list the merge of any two lists doesn’t affect the final result nor the merge of any other lists Thus, we could divide the list of k sorted lists into several lists and each contains 1 or 2 sorted lists for us to merge. Then we can always merge 2 sorted lists.\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def mergeKLists(self, lists: List[Optional[ListNode]]) -\u003e Optional[ListNode]: # merge 2 sorted lists recursively def merge2list(list1, list2): if not list1: return list2 if not list2: return list1 # Choose the smaller head node and merge the remaining nodes. if list1.val \u003e list2.val: new_node = ListNode(list2.val) new_node.next = merge2list(list1, list2.next) else: new_node = ListNode(list1.val) new_node.next = merge2list(list1.next, list2) return new_node n = len(lists) # Base cases: empty or single list. if n == 0: return None if n == 1: return lists[0] # Split lists in half and merge recursively. left_merged_lists = self.mergeKLists(lists[:n//2]) right_merged_lists = self.mergeKLists(lists[n//2:]) # Merge the two halves. return merge2list(left_merged_lists, right_merged_lists) Time Complexity: O(NlogK) where N is the number of total elements in lists, since we divide lists into half so the height of the resulted tree is logK, and each node need to visit all elements waiting to be sorted thus the actual time should be $O(∑_{i=1}^N log​k​)=O(Nlogk)$ Space Complexity: O(NlogK) the height of recursion stack should logK for mergeKLists and merge2list could need N stacks in the worst case (the recursion stack could go up to N)\nTakeaways When faced with unknown data in a query that requires consolidation into a single data point, and where partial data aggregation won't affect the overall outcome or aggregation of other data, it's advisable to employ the `divide-n-conquer` approach. This strategy is particularly relevant if the scenario reminds you of MapReduce. ","wordCount":"1257","inLanguage":"en","image":"https://ydeng11.github.io/ihelio/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-10-08T22:46:03-04:00","dateModified":"2023-10-08T22:46:03-04:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-divide--conquer/"},"publisher":{"@type":"Organization","name":"iHelio","logo":{"@type":"ImageObject","url":"https://ydeng11.github.io/ihelio/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ydeng11.github.io/ihelio/ accesskey=h title="Home (Alt + H)"><img src=https://ydeng11.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://ydeng11.github.io/ihelio/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://ydeng11.github.io/ihelio/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://ydeng11.github.io/ihelio/search/ title=Search><span>Search</span></a></li><li><a href=https://ydeng11.github.io/ihelio/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ydeng11.github.io/ihelio/>Home</a>&nbsp;»&nbsp;<a href=https://ydeng11.github.io/ihelio/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Coding Pattern: Divide & Conquer</h1><div class=post-meta><span title='2023-10-08 22:46:03 -0400 EDT'>October 8, 2023</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1257 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/ydeng11/ihelio/tree/main/content/posts/2023/Coding%20Pattern:%20Divide%20&%20Conquer.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h3 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h3><p>The <code>Divide-n-Conquer</code> strategy often employs recursion, as it relies on applying the same method to reduce the problem size by half and subsequently combining the outcomes for the ultimate solution.</p><p>I view <code>Divide-n-Conquer</code> in a light similar to MapReduce, particularly when the task involves transformation. MapReduce breaks down a large problem into more manageable, independent sub-problems. Since each of these sub-problems operates autonomously, we can address them sequentially and still integrate their solutions. Key to this approach is ensuring the main problem can be independently segmented and the derived solutions can be seamlessly merged.</p><p>The typical blueprint for <code>Divide-n-Conquer</code> involves a recursive function. This function produces a result when the size becomes null and provides mechanisms to split the problem and amalgamate the solutions. Consequently, time complexity predominantly depends on this recursive function.</p><h3 id=example-questions>Example Questions<a hidden class=anchor aria-hidden=true href=#example-questions>#</a></h3><h4 id=108-convert-sorted-array-to-binary-search-treehttpsleetcodecomproblemsconvert-sorted-array-to-binary-search-tree><a href=https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/>108. Convert Sorted Array to Binary Search Tree</a><a hidden class=anchor aria-hidden=true href=#108-convert-sorted-array-to-binary-search-treehttpsleetcodecomproblemsconvert-sorted-array-to-binary-search-tree>#</a></h4><pre tabindex=0><code class=language-ad-question data-lang=ad-question>Given an integer array `nums` where the elements are sorted in **ascending order**, convert _it to a_ 

**_height-balanced_**

 _binary search tree_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

**Input:** nums = [-10,-3,0,5,9]
**Output:** [0,-3,9,-10,null,5]
**Explanation:** [0,-10,5,null,-3,null,9] is also accepted:
![](https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg)

**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)

**Input:** nums = [1,3]
**Output:** [3,1]
**Explanation:** [1,null,3] and [3,1] are both height-balanced BSTs.
</code></pre><h5 id=solution>Solution:<a hidden class=anchor aria-hidden=true href=#solution>#</a></h5><p>The question asks to <strong>transform</strong> the sorted array into a height-balanced BST so:</p><ol><li>the number of nodes on the left and right should be very close -> implies how to divide the question</li><li>the BST is resulted from the sorted array -> indicates <strong>transformation</strong></li><li>If we split the array into separate arrays, each array is still sorted and can be transformed into a height-balanced BST, thus we can make a BST using these small BST</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Definition for a binary tree node.</span>
</span></span><span class=line><span class=cl><span class=c1># class TreeNode:</span>
</span></span><span class=line><span class=cl><span class=c1>#     def __init__(self, val=0, left=None, right=None):</span>
</span></span><span class=line><span class=cl><span class=c1>#         self.val = val</span>
</span></span><span class=line><span class=cl><span class=c1>#         self.left = left</span>
</span></span><span class=line><span class=cl><span class=c1>#         self.right = right</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>sortedArrayToBST</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>nums</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=n>Optional</span><span class=p>[</span><span class=n>TreeNode</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>        <span class=c1># We need an recursion to convert the divided arrays into BST</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=nf>helper</span><span class=p>(</span><span class=n>nums</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	        <span class=c1># if the array is empty, we should create a null node</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>None</span>
</span></span><span class=line><span class=cl>            <span class=c1># if there is only one value in the array, this tree has only one node</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>TreeNode</span><span class=p>(</span><span class=n>nums</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>
</span></span><span class=line><span class=cl>			<span class=c1># we are building a height-balanced BST, thus we should divide the nums array into half each time        </span>
</span></span><span class=line><span class=cl>            <span class=n>mid</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span> <span class=o>//</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>			<span class=c1># the value at the mid is the root</span>
</span></span><span class=line><span class=cl>            <span class=n>root</span> <span class=o>=</span> <span class=n>TreeNode</span><span class=p>(</span><span class=n>nums</span><span class=p>[</span><span class=n>mid</span><span class=p>])</span>
</span></span><span class=line><span class=cl>	        <span class=c1># the left branch is the BST resulted from the left half array</span>
</span></span><span class=line><span class=cl>            <span class=n>root</span><span class=o>.</span><span class=n>left</span> <span class=o>=</span> <span class=n>helper</span><span class=p>(</span><span class=n>nums</span><span class=p>[:</span><span class=n>mid</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=c1># the right branch is the BST resulted from the right half array</span>
</span></span><span class=line><span class=cl>            <span class=n>root</span><span class=o>.</span><span class=n>right</span> <span class=o>=</span> <span class=n>helper</span><span class=p>(</span><span class=n>nums</span><span class=p>[</span><span class=n>mid</span><span class=o>+</span><span class=mi>1</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>root</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>helper</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span>
</span></span></code></pre></div><p>Time Complexity: <code>O(N)</code> even it is recursion, we are visiting each element exactly once
Space Complexity: <code>O(logN)</code> it is the height of the BST tree we are creating</p><h4 id=215-kth-largest-element-in-an-arrayhttpsleetcodecomproblemskth-largest-element-in-an-array><a href=https://leetcode.com/problems/kth-largest-element-in-an-array/>215. Kth Largest Element in an Array</a><a hidden class=anchor aria-hidden=true href=#215-kth-largest-element-in-an-arrayhttpsleetcodecomproblemskth-largest-element-in-an-array>#</a></h4><pre tabindex=0><code class=language-ad-question data-lang=ad-question>Given an integer array `nums` and an integer `k`, return _the_ `kth` _largest element in the array_.

Note that it is the `kth` largest element in the sorted order, not the `kth` distinct element.

Can you solve it without sorting?

**Example 1:**

**Input:** nums = [3,2,1,5,6,4], k = 2
**Output:** 5

**Example 2:**

**Input:** nums = [3,2,3,1,2,4,5,5,6], k = 4
**Output:** 4

**Constraints:**

- `1 &lt;= k &lt;= nums.length &lt;= 105`
- `-104 &lt;= nums[i] &lt;= 104`
</code></pre><h5 id=solution-1>Solution<a hidden class=anchor aria-hidden=true href=#solution-1>#</a></h5><p>This solution is to use quick select to find the <code>Kth</code> largest value from a non-sorted array. Quick select is essentially <code>divide-n-conquer</code> as:</p><ol><li>we divide the array using a random pivot</li><li>check which subarray could contain the <code>kth</code> largest value</li><li>continue the search until we get the result</li><li>we need a <code>recursion</code> function to work on each array</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>heapq</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>findKthLargest</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>nums</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>],</span> <span class=n>k</span><span class=p>:</span> <span class=nb>int</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>int</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=nf>quick_select</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=n>k</span><span class=p>):</span>
</span></span><span class=line><span class=cl>	        <span class=c1># random select a value from the array</span>
</span></span><span class=line><span class=cl>            <span class=n>pivot</span> <span class=o>=</span> <span class=n>random</span><span class=o>.</span><span class=n>choice</span><span class=p>(</span><span class=n>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1># create the subarray contains the larger, smaller and equaivalent values</span>
</span></span><span class=line><span class=cl>            <span class=n>more</span><span class=p>,</span> <span class=n>less</span><span class=p>,</span> <span class=n>equal</span> <span class=o>=</span> <span class=p>[],</span> <span class=p>[],</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>num</span> <span class=ow>in</span> <span class=n>nums</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>num</span> <span class=o>&gt;</span> <span class=n>pivot</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>more</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>elif</span> <span class=n>num</span> <span class=o>&lt;</span> <span class=n>pivot</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>less</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=n>equal</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>num</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		    <span class=c1># If there are more than k elements larger than the pivot in array more, we can search kth largest value from more and it is same kth largest value as the original array        </span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>more</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=n>k</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>quick_select</span><span class=p>(</span><span class=n>more</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1># If the number of larger and equaivalent values are less than k, the kth largest value should be in less array, but we cannot find kth largest value from less since it will result in a much smaller value.</span>
</span></span><span class=line><span class=cl>            <span class=c1># we need identify the new kth target in the less array</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>more</span><span class=p>)</span> <span class=o>+</span> <span class=nb>len</span><span class=p>(</span><span class=n>equal</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>k</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>quick_select</span><span class=p>(</span><span class=n>less</span><span class=p>,</span> <span class=n>k</span> <span class=o>-</span> <span class=nb>len</span><span class=p>(</span><span class=n>more</span><span class=p>)</span> <span class=o>-</span> <span class=nb>len</span><span class=p>(</span><span class=n>equal</span><span class=p>))</span> 
</span></span><span class=line><span class=cl>            <span class=c1># otherwise, the pivot should be the kth largest value</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>pivot</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>quick_select</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=n>k</span><span class=p>)</span>
</span></span></code></pre></div><h4 id=23-merge-k-sorted-listshttpsleetcodecomproblemsmerge-k-sorted-lists><a href=https://leetcode.com/problems/merge-k-sorted-lists/>23. Merge k Sorted Lists</a><a hidden class=anchor aria-hidden=true href=#23-merge-k-sorted-listshttpsleetcodecomproblemsmerge-k-sorted-lists>#</a></h4><pre tabindex=0><code class=language-ad-question data-lang=ad-question>You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

_Merge all the linked-lists into one sorted linked-list and return it._

**Example 1:**

**Input:** lists = [[1,4,5],[1,3,4],[2,6]]
**Output:** [1,1,2,3,4,4,5,6]
**Explanation:** The linked-lists are:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
merging them into one sorted list:
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6

**Example 2:**

**Input:** lists = []
**Output:** []

**Example 3:**

**Input:** lists = [[]]
**Output:** []

**Constraints:**

- `k == lists.length`
- `0 &lt;= k &lt;= 104`
- `0 &lt;= lists[i].length &lt;= 500`
- `-104 &lt;= lists[i][j] &lt;= 104`
- `lists[i]` is sorted in **ascending order**.
- The sum of `lists[i].length` will not exceed `104`.
</code></pre><h5 id=solution-2>Solution<a hidden class=anchor aria-hidden=true href=#solution-2>#</a></h5><p>This is an advanced question based off <a href=https://leetcode.com/problems/merge-two-sorted-lists/>21. Merge Two Sorted Lists</a>.</p><p>And this question has the following characteristics leading to <code>divide-n-conquer</code>:</p><ol><li>merge k sorted list is the same as merge 2 sorted lists, since we want one single sorted list in the end</li><li>it is similar to MapReduce, aggregate multiple lists into one list</li><li>the merge of any two lists doesn&rsquo;t affect the final result nor the merge of any other lists</li></ol><p>Thus, we could divide the list of k sorted lists into several lists and each contains 1 or 2 sorted lists for us to merge. Then we can always merge 2 sorted lists.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Definition for singly-linked list.</span>
</span></span><span class=line><span class=cl><span class=c1># class ListNode:</span>
</span></span><span class=line><span class=cl><span class=c1>#     def __init__(self, val=0, next=None):</span>
</span></span><span class=line><span class=cl><span class=c1>#         self.val = val</span>
</span></span><span class=line><span class=cl><span class=c1>#         self.next = next</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>mergeKLists</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>lists</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=n>Optional</span><span class=p>[</span><span class=n>ListNode</span><span class=p>]])</span> <span class=o>-&gt;</span> <span class=n>Optional</span><span class=p>[</span><span class=n>ListNode</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1># merge 2 sorted lists recursively</span>
</span></span><span class=line><span class=cl>        <span class=k>def</span> <span class=nf>merge2list</span><span class=p>(</span><span class=n>list1</span><span class=p>,</span> <span class=n>list2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=n>list1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>list2</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=n>list2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>list1</span>
</span></span><span class=line><span class=cl>            <span class=c1># Choose the smaller head node and merge the remaining nodes.</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>list1</span><span class=o>.</span><span class=n>val</span> <span class=o>&gt;</span> <span class=n>list2</span><span class=o>.</span><span class=n>val</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>new_node</span> <span class=o>=</span> <span class=n>ListNode</span><span class=p>(</span><span class=n>list2</span><span class=o>.</span><span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>new_node</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>merge2list</span><span class=p>(</span><span class=n>list1</span><span class=p>,</span> <span class=n>list2</span><span class=o>.</span><span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=n>new_node</span> <span class=o>=</span> <span class=n>ListNode</span><span class=p>(</span><span class=n>list1</span><span class=o>.</span><span class=n>val</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>new_node</span><span class=o>.</span><span class=n>next</span> <span class=o>=</span> <span class=n>merge2list</span><span class=p>(</span><span class=n>list1</span><span class=o>.</span><span class=n>next</span><span class=p>,</span> <span class=n>list2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>new_node</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>n</span> <span class=o>=</span> <span class=nb>len</span><span class=p>(</span><span class=n>lists</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>        <span class=c1># Base cases: empty or single list. </span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span> <span class=k>return</span> <span class=kc>None</span> 
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span> <span class=k>return</span> <span class=n>lists</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1># Split lists in half and merge recursively.</span>
</span></span><span class=line><span class=cl>        <span class=n>left_merged_lists</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>mergeKLists</span><span class=p>(</span><span class=n>lists</span><span class=p>[:</span><span class=n>n</span><span class=o>//</span><span class=mi>2</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=n>right_merged_lists</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>mergeKLists</span><span class=p>(</span><span class=n>lists</span><span class=p>[</span><span class=n>n</span><span class=o>//</span><span class=mi>2</span><span class=p>:])</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=c1># Merge the two halves.</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>merge2list</span><span class=p>(</span><span class=n>left_merged_lists</span><span class=p>,</span> <span class=n>right_merged_lists</span><span class=p>)</span>
</span></span></code></pre></div><p><em><strong>Time Complexity:</strong></em> <code>O(NlogK)</code> where <code>N</code> is the number of total elements in <code>lists</code>, since we divide <code>lists</code> into half so the height of the resulted tree is <code>logK</code>, and each node need to visit all elements waiting to be sorted thus the actual time should be $O(∑_{i=1}^N log​k​)=O(Nlogk)$
<em><strong>Space Complexity:</strong></em> <code>O(NlogK)</code> the height of recursion stack should <code>logK</code> for <code>mergeKLists</code> and <code>merge2list</code> could need <code>N</code> stacks in the worst case (the recursion stack could go up to <code>N</code>)</p><h3 id=takeaways>Takeaways<a hidden class=anchor aria-hidden=true href=#takeaways>#</a></h3><pre tabindex=0><code class=language-ad-summary data-lang=ad-summary>When faced with unknown data in a query that requires consolidation into a single data point, and where partial data aggregation won&#39;t affect the overall outcome or aggregation of other data, it&#39;s advisable to employ the `divide-n-conquer` approach. This strategy is particularly relevant if the scenario reminds you of MapReduce.
</code></pre></div><footer class=post-footer><ul class=post-tags><li><a href=https://ydeng11.github.io/ihelio/tags/algorithm/>Algorithm</a></li><li><a href=https://ydeng11.github.io/ihelio/tags/leetcode/>LeetCode</a></li></ul><nav class=paginav><a class=prev href=https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-two-pointers/><span class=title>« Prev</span><br><span>Coding Pattern: Two Pointers</span>
</a><a class=next href=https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-binary-search/><span class=title>Next »</span><br><span>Coding Pattern: Binary Search</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Divide & Conquer on x" href="https://x.com/intent/tweet/?text=Coding%20Pattern%3a%20Divide%20%26%20Conquer&amp;url=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-divide--conquer%2f&amp;hashtags=Algorithm%2cLeetCode"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Divide & Conquer on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-divide--conquer%2f&amp;title=Coding%20Pattern%3a%20Divide%20%26%20Conquer&amp;summary=Coding%20Pattern%3a%20Divide%20%26%20Conquer&amp;source=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-divide--conquer%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Divide & Conquer on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-divide--conquer%2f&title=Coding%20Pattern%3a%20Divide%20%26%20Conquer"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Divide & Conquer on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-divide--conquer%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Divide & Conquer on whatsapp" href="https://api.whatsapp.com/send?text=Coding%20Pattern%3a%20Divide%20%26%20Conquer%20-%20https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-divide--conquer%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Divide & Conquer on telegram" href="https://telegram.me/share/url?text=Coding%20Pattern%3a%20Divide%20%26%20Conquer&amp;url=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-divide--conquer%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Coding Pattern: Divide & Conquer on ycombinator" href="https://news.ycombinator.com/submitlink?t=Coding%20Pattern%3a%20Divide%20%26%20Conquer&u=https%3a%2f%2fydeng11.github.io%2fihelio%2fposts%2f2023%2fcoding-pattern-divide--conquer%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//ihelio-today.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://ydeng11.github.io/ihelio/>iHelio</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>