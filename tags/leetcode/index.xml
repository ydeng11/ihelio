<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>LeetCode on iHelio</title>
    <link>https://ydeng11.github.io/ihelio/tags/leetcode/</link>
    <description>Recent content in LeetCode on iHelio</description>
    <image>
      <title>iHelio</title>
      <url>https://ydeng11.github.io/ihelio/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://ydeng11.github.io/ihelio/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- 0.128.2</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 30 Nov 2023 23:37:39 -0500</lastBuildDate>
    <atom:link href="https://ydeng11.github.io/ihelio/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Coding Pattern: Kadane&#39;s Algo</title>
      <link>https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-kadanes-algo/</link>
      <pubDate>Thu, 30 Nov 2023 23:37:39 -0500</pubDate>
      <guid>https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-kadanes-algo/</guid>
      <description>Imagine you&amp;rsquo;re walking along a path that has treasure chests and traps. Some chests have gold coins, and some traps take away coins. You want to find the part of the path where you can get the most coins.
The key idea: It is a dynamic programming algorithm for finding the maximum contiguous sum subarray in a given array. It is a simple and efficient algorithm that works by maintaining two variables:</description>
    </item>
    <item>
      <title>Coding Pattern: Dynamic Programming</title>
      <link>https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-dynamic-programming/</link>
      <pubDate>Thu, 30 Nov 2023 16:28:21 -0400</pubDate>
      <guid>https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-dynamic-programming/</guid>
      <description>Preface Facing the Dynamic Programming Challenge
Like many others, I initially found Dynamic Programming (DP) on LeetCode daunting and perplexing. However, this challenging journey led to profound insights. My initial misconception was that DP was all about complexity, but I learned it&amp;rsquo;s fundamentally about simplifying complex problems into manageable segments. Here&amp;rsquo;s my journey into understanding DP and why it&amp;rsquo;s a crucial tool in a programmer&amp;rsquo;s toolkit.
Unraveling Dynamic Programming The Essence of DP</description>
    </item>
    <item>
      <title>Coding Pattern: Recursion</title>
      <link>https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-recursion/</link>
      <pubDate>Sun, 05 Nov 2023 16:41:32 -0500</pubDate>
      <guid>https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-recursion/</guid>
      <description>Overview Recursion is a way of solving a problem by breaking it down into smaller problems of the same type. The smaller problems are then solved recursively, until a base case is reached. The base case is a simple problem that can be solved without recursion.
Imagine you have a big box of toy blocks, and each block represents a problem you need to solve. Some blocks are big (complex problems), and some are tiny (simple problems).</description>
    </item>
    <item>
      <title>Coding Pattern: Trie</title>
      <link>https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-trie/</link>
      <pubDate>Sun, 22 Oct 2023 21:41:02 -0400</pubDate>
      <guid>https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-trie/</guid>
      <description>Overview The union-find algorithm is a data structure and algorithm that maintains a collection of disjoint sets. A disjoint set is a set of elements that are not connected to each other. The union-find algorithm can be used to perform the following operations:
Find: Find the set that an element belongs to. Union: Merge two sets together. The union-find algorithm is often used to solve problems that involve graph connectivity. For example, the union-find algorithm can be used to determine whether two nodes in a graph are connected, or to find all of the connected components in a graph.</description>
    </item>
    <item>
      <title>Coding Pattern: Two Pointers</title>
      <link>https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-two-pointers/</link>
      <pubDate>Thu, 12 Oct 2023 00:44:00 -0400</pubDate>
      <guid>https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-two-pointers/</guid>
      <description>Overview It is not easy to summarize the pattern of Two Pointers, but most likely it is used for list and linked list and the required time complexity is O(N) - the underlying pattern allows us to use Two Pointers to go through the list once to get the results.
Common usage:
Linear Structure: Typically applied to a sorted array or linked list. Two pointers might move in the same direction or in opposite directions.</description>
    </item>
    <item>
      <title>Coding Pattern: Divide &amp; Conquer</title>
      <link>https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-divide--conquer/</link>
      <pubDate>Sun, 08 Oct 2023 22:46:03 -0400</pubDate>
      <guid>https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-divide--conquer/</guid>
      <description>Overview The Divide-n-Conquer strategy often employs recursion, as it relies on applying the same method to reduce the problem size by half and subsequently combining the outcomes for the ultimate solution.
I view Divide-n-Conquer in a light similar to MapReduce, particularly when the task involves transformation. MapReduce breaks down a large problem into more manageable, independent sub-problems. Since each of these sub-problems operates autonomously, we can address them sequentially and still integrate their solutions.</description>
    </item>
    <item>
      <title>Coding Pattern: Binary Search</title>
      <link>https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-binary-search/</link>
      <pubDate>Sun, 08 Oct 2023 16:28:21 -0400</pubDate>
      <guid>https://ydeng11.github.io/ihelio/posts/2023/coding-pattern-binary-search/</guid>
      <description>Overview In one word, binary search is to search for a target in a sorted array. The idea is to shrink the search space to empty.
It must be sorted because we can be sure how to shrink the search space and we normally reduce the search space by half so the time complexity is O(logN) where N is the size of entire search space.
One common problem to understand Binary Search is how to identify the boundary of the search space.</description>
    </item>
  </channel>
</rss>
